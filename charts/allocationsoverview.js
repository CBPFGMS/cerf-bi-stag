(function d3ChartIIFE() {

	const width = 1100,
		padding = [4, 4, 4, 4],
		panelHorizontalPadding = 4,
		buttonsPanelHeight = 30,
		mapPanelHeight = 510,
		legendPanelHeight = 80,
		legendPanelWidth = 86,
		legendPanelHorPadding = 2,
		legendPanelVertPadding = 2,
		mapZoomButtonHorPadding = 10,
		mapZoomButtonVertPadding = 10,
		mapZoomButtonSize = 26,
		maxColumnRectHeight = 16,
		maxPieSize = 20,
		minPieSize = 1,
		buttonsNumber = 8,
		groupNamePadding = 2,
		topPanelHeight = 60,
		cerfCircleRadius = 20,
		zoomBoundingMarginHor = 26,
		zoomBoundingMarginVert = 6,
		innerTooltipDivWidth = 290,
		clusterIconSize = 18,
		clusterIconPadding = 2,
		labelsColumnPadding = 2,
		stackedPadding = [30, 14, 98, 14],
		stackedSvgWidth = width,
		stackedSvgHeight = 380,
		stackedBarMaxWidth = 65,
		barLabelPadding = 16,
		barLabelPaddingBase = 3,
		legendGroupRectSize = 12,
		legendGroupPadding = legendGroupRectSize + 4,
		unBlue = "#1F69B3",
		cerfColor = "#F9D25B",
		choroplethColorTotal = "#5693CE",
		choroplethColorRR = "#F0DA8A",
		choroplethColorUnderfunded = "#B8C9E6",
		countriesBackground = "#F4F4F4",
		classPrefix = "allocover",
		globalIsoCode = "0G",
		countryNameMaxLength = 60,
		colorInterpolatorTotal = d3.interpolateRgb("#FFFFFF", d3.color(choroplethColorTotal).darker(0.1)),
		colorInterpolatorRR = d3.interpolateRgb("#FFFFFF", d3.color(choroplethColorRR).darker(0.1)),
		colorInterpolatorUnderfunded = d3.interpolateRgb("#FFFFFF", d3.color(choroplethColorUnderfunded).darker(0.1)),
		isTouchScreenOnly = (window.matchMedia("(pointer: coarse)").matches && !window.matchMedia("(any-pointer: fine)").matches),
		isBookmarkPage = window.location.hostname + window.location.pathname === "cbpfgms.github.io/cerf-bi-stag/bookmark.html",
		bookmarkSite = "https://cbpfgms.github.io/cerf-bi-stag/bookmark.html?",
		fadeOpacity = 0.2,
		tooltipMargin = 8,
		tooltipSvgWidth = 310,
		tooltipSvgHeight = 80,
		showNamesMargin = 12,
		tooltipSvgPadding = [12, 36, 2, 96],
		height = padding[0] + padding[2] + topPanelHeight + buttonsPanelHeight + mapPanelHeight + (2 * panelHorizontalPadding),
		windowHeight = window.innerHeight,
		currentDate = new Date(),
		currentYear = currentDate.getFullYear(),
		localVariable = d3.local(),
		localStorageTime = 3600000,
		duration = 1000,
		shortDuration = 250,
		stickHeight = 2,
		lollipopRadius = 4,
		labelPadding = 2,
		formatMoney0Decimals = d3.format(",.0f"),
		formatSIaxes = d3.format("~s"),
		formatNumberSI = d3.format(".3s"),
		chartTitleDefault = "Allocations",
		vizNameQueryString = "allocations",
		dataUrl = "https://cbpfgms.github.io/pfbi-data/cerf/cerf_allocationSummary_byorg.csv",
		mapUrl = "https://cbpfgms.github.io/pfbi-data/map/unworldmap.json",
		masterFundsUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstCountry.json",
		masterAllocationTypesUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstAllocation.json",
		masterUnAgenciesUrl = "https://cerfgms-webapi.unocha.org/v1/agency/All.json",
		masterPartnerTypesUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstOrganization.json",
		masterClusterTypesUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstCluster.json",
		csvDateFormat = d3.utcFormat("_%Y%m%d_%H%M%S_UTC"),
		moneyBagdAttribute = ["M83.277,10.493l-13.132,12.22H22.821L9.689,10.493c0,0,6.54-9.154,17.311-10.352c10.547-1.172,14.206,5.293,19.493,5.56 c5.273-0.267,8.945-6.731,19.479-5.56C76.754,1.339,83.277,10.493,83.277,10.493z",
			"M48.297,69.165v9.226c1.399-0.228,2.545-0.768,3.418-1.646c0.885-0.879,1.321-1.908,1.321-3.08 c0-1.055-0.371-1.966-1.113-2.728C51.193,70.168,49.977,69.582,48.297,69.165z",
			"M40.614,57.349c0,0.84,0.299,1.615,0.898,2.324c0.599,0.729,1.504,1.303,2.718,1.745v-8.177 c-1.104,0.306-1.979,0.846-2.633,1.602C40.939,55.61,40.614,56.431,40.614,57.349z",
			"M73.693,30.584H19.276c0,0-26.133,20.567-17.542,58.477c0,0,2.855,10.938,15.996,10.938h57.54 c13.125,0,15.97-10.938,15.97-10.938C99.827,51.151,73.693,30.584,73.693,30.584z M56.832,80.019 c-2.045,1.953-4.89,3.151-8.535,3.594v4.421H44.23v-4.311c-3.232-0.318-5.853-1.334-7.875-3.047 c-2.018-1.699-3.307-4.102-3.864-7.207l7.314-0.651c0.3,1.25,0.856,2.338,1.677,3.256c0.823,0.911,1.741,1.575,2.747,1.979v-9.903 c-3.659-0.879-6.348-2.22-8.053-3.997c-1.716-1.804-2.565-3.958-2.565-6.523c0-2.578,0.96-4.753,2.897-6.511 c1.937-1.751,4.508-2.767,7.721-3.034v-2.344h4.066v2.344c2.969,0.306,5.338,1.159,7.09,2.565c1.758,1.406,2.877,3.3,3.372,5.658 l-7.097,0.774c-0.43-1.849-1.549-3.118-3.365-3.776v9.238c4.485,1.035,7.539,2.357,9.16,3.984c1.634,1.635,2.441,3.725,2.441,6.289 C59.898,75.656,58.876,78.072,56.832,80.019z"
		],
		yearsArray = [],
		countryNames = {},
		centroids = {},
		partnerTypes = [],
		cerfAllocationTypes = {},
		cerfTypeKeys = ["3", "4"],
		fundNamesList = {},
		fundAbbreviatedNamesList = {},
		fundIsoCodesList = {},
		fundIsoCodes3List = {},
		fundLatLongList = {},
		partnersList = {},
		clustersList = {},
		allocationTypesList = {},
		unAgenciesNamesList = {},
		unAgenciesShortNamesList = {},
		fundNamesListKeys = [],
		separator = "##",
		chartState = {
			selectedYear: [],
			selectedCluster: [],
			selectedCerfAllocation: null,
			showNames: null
		};

	const clustersIconsData = {

	1: "data:image/png;base64,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",
	2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAtCAYAAADoSujCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEYElEQVRogdWXX0xbZRjGf++hIAUdm24xCwHTMi80xAtYtBcmZVUDcbJpBBbjjFtixCiJUrLsTsKVmUkBE6Mj8ca4+Qc2FyYxUQKli5mLgRi98cbCJHMmZmHgxh8LPa8XUIECpedwSspz+Z33+d7nd877fWmFDMjf+Xu5oVKHylOKekEeQHQa5C/gF+ByLPbvt1dPP3Jnq71k63GXFfjg+qNqxkMo1Yik3FvRCVF5z5ySDyNtnjm7PR0DCLSPvaFidoDkW/Gp8quKHI00e67b6WvYMa0bRPR9q+EBRHjMUP0pEIo+bqevcwBwClW1ZRb2mYZ8X9Ux+oRVq2MAQ83eLhNeV9S04xcoAr7zh8Z8Fn3Oyt8efU2ELkFsvRyFKTWlJtLiuZZOveMAsL0QGQGA7YNw7AwkKxIs+0Sgye7BFigSQ3tRTfmSMwYAEG4u+xjhLdu3kzKMSEpvRgFgEUJFzlg2KgNz6qrbrCzjAAA5ol9b9ajonl3gBqjsGs6t6hh9t6oz+mJy3bYAxKHUqkeQipgx3x/ojD5438yerwTaxKSnqmO0cXVdhuULjbvzjfkfBKmw41d0WpDC5QVVwXhzMOg5C9vwBUpKSmKC/GbXvyo8gIgo5keBzmjT4vMMyRcadxcQ9w22eML+1rBLdpeeF6TBsQaqisiJjAD4QuPufFnoFeGQqfpSJFh2wd8adhlFpecQOeZUH1W96fgIrQj/DOAyRL7wt0frIm2HFsyp8eOgXy4nYEBMCShM2eklEHMcwG0stCyFT2gVxN5i7yKEMjCrrtrBFk8YqLYKoapxUSPoOMA/BRNnFL2UtPw/RE+DxPcWe4/Pqqv2WkvpLMC+yZmfgZF0e6hqHHh1sMVzyZEz4AuNu93GQo8pejbyTllfZddw7uLdLS8klS6gZnU4eGAwsVDfrTm3boxeQOR5K+GHgmXnwYFrNDHzwGFRuejvjD430nhw/k7B7WNrvoQSmdW8H1cuTdwcrbAbfssASQcWgTxRuRhoj9augVia+cTYJPTkbe+IKj12wi/1dCb8qmYQM1TrBoNl31R2Defumrn/9KzpCiWHT8jfGnZJ0UOfi1BvJbxtgKWZvww8vVGNQgylYSjo7U1nz/puzbn159inwMur9lGNC3IyHPR+tp7P8gitmPkNw8PiOIE2pqpZqZ4GiZuTf5xQtDuxlnjzG4Vf6pO+Uo3NGikDhYX3HOlrLJ6x0qO+W3P+vjF60hDKMczu8NsPX01VnzZAOmOTkKpe0bzZw5Gm8rvp7m9XaQFka3hIAyCbw8MmANkeHlIA7ITwsAHATgkP6wDspPCQBLDTwsMKAKvhc+MFz/af2j+d0XRpSGDnhgeQnRwewJVvzHeBbBoeZeDewvwjfY37Lf22ybQMIY1/QzZ/mG2HDJRIyoosDg9gmCKvAMPrPVTVK664+2i2hoelW8jfMbbbQPuBg4kH2Xhg15MBEGn2TBquvBqUPpS7KOfmNLcm28MD/Ac0rl/qXg0VxwAAAABJRU5ErkJggg==",
	3: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAA7CAYAAAA9xQlEAAAACXBIWXMAAAsTAAALEwEAmpwYAAACWUlEQVRoge2av2tTURSAv/OSWLCgFrolQ0pc/BfEYiIqUnRw6OzYQQnaTRARHSyIDXWQ2k0noU7S2R/YxUWobtW86qBd/VG1oXnvOLRSTZ7pizftfa/cb0rePfdwP7jnnpdLpFLzFZuoXn46Xpr41/Dxifr+oE8+Rww1gRlv+1a27WRVdSzNAohIJtUCANn2RzoVKnMAGQ8JQ7kmwuGdXlhc2gRC4dHzS6X539/LNf8YJFcg9VvICdgmcQKn733c2018xCm08xy5+2Eg1wjOoIyu/GicrEzWPwGPQ49ZVnnTaW4CBOR8bjW4jpBDQABEikDVU6rBHl3qNNu+gFDoPC5DnYYTVwPd4gRs4wRsk3oB82NUWUNYAKJ+9v1HPj240QdiYSSgylfP0+EnF0uvTfK0Uqn5V4AbcWKNtpDAbK8XDzCYH7qJshIn1rQGDhjOj+Tb8tt+oC9OrJGAip4t1/yxE7eW+03y/MnRqcVCI8jcR8jFiTeqAUE8YLqZ/TldqfkmqTYJ2Xiji0fqj1EnYBvjRqaqDzzxHgYarvViQag36El4FZFDccLNBJT5Z+Olc0Y5Ihi+8/5lthnUEdmynM22kNDzJgbwolpcAr7EiTUTUB05NbW4zyhHBJXb70YQidUkzbaQSLERZBbKk/6coN+Ncm3mLCiMxm0F5m+jIkWBC111n61SdhGb+mPUCdjGCdjGCdjGCdjGCdjGCdjGCdjGCdjGCdhm9wmISv7vJ5pvjUkS0vq3S0VD0fVLJUUyIvT83qeXtF2rCOIhDKx/Tj67rwbShKKvfgFZK5MCBawJXgAAAABJRU5ErkJggg==",
	4: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFNklEQVRoge1ZXWxURRg9Z3YXqqj8tUSSUtilYGOIMcKDJsC2S8Co0cQoTTQxJIQHAsR2KQUUBaoQwba7LRpME+MLkICFGHmByM9miVETiWjiD3/dBQJiFGJr+O/uPT5QSrvdvezeXakPPU/3znxzvnPunTszd4b4DzC38eKIbte11SQXQ5CgNk/ywU0H6sdfLXQuFpRNYqA1/qolNRKc2L9KvxNsmN3l/bShgVahUhbMQCB05inBagUx0y5OwvcusuZQ0PttIfLmbWDOR+fHWt031wpYStKVVSNJIrar26yMrvT+kU9+xwamtx31PHx1zBIQDQRGOuEQdJVA03CT/GB/zdSbTjgcGQiE489ZssIkH7uHwC9uJ+HLtnHSCUMTPBz07stVS04GZrecnmIss5HE/FwEBZrjVRbVQuKJe6Q4CCVrI8un/JKtpqwMzG28OCLhvlYvcTWJ4TbK/xa5uaTzWri9YdqtvlX+dRG3GTlxIYANIEoyc6Ab0CeuW1h7cPXkrvwMSKxqib8BaDPARzPnlAVghyehFQfqy/+0o5y59exoz43EepBLALgzp9ZlgO+XlHo/bq9mMmcD/tDpGQS3kHzGThCgKCzWROp8P9nHpfA3xSuMsVpAPmvLDv0goiZaO/nrdPUDDMwKnRnvZnK9gEUEjQ3zeRBrIrXebSDVT9y6iNuMLHsX4EIBHlI7r1uet76rK7ueShMIdbwooBWkN3MuSeBut9GKg7WTz6U10DssAu+ReCQjGXQdwhZr2PUN0WXTrqSLqAx3rCG4IaV4ayToW5ou/unmcw8UmcSbFN4B8ZCNj2skGq1Osyna4L3Ra6AqHHtJQojE5MzCAUGfu4n61KeQiqpQ7CSIKf2T4x9/l3e03TJiVtOpCW5jGgFUg8zYvSV0kFgeCfr2sioUWwGi0U4QpB9B1kSCviO2cT2oDHUcT50jBHT5O71jslkHVYVjsyG1gnzSVhZUZ0Cssom5JGBxcalvRrbiAQDEtoFF2J7tIi4S9B0pLvXNELAYwCWbRKvcAIrT1CQAfWYlu9dEV1TYEKSHOs9t5qgyD8CFgDwSdt6Q5+1cOHqGzjZ/OL7LyFotMkhgWD/5wDhWhWMa0FrJabnMhvcDgdYzj8uyBmhKO0z+38QDwOGaSb+mK884EzqBv/lUOY3rFQhzSFQA6umevCThOIhDNIndkZqpHYXKWRAD/taTpUy6PwRUTcB1d3bpvZhAYgKAuUq6NlaGY7uM5V55uK7sQr65M8+0WaIqFJtnLPcxEq9l80ND0kXgdTFxLNDSMTff/HkZqGyO+UF9iTsjmTRwQEjFnRiiRMLeQKhjVj4aHBuY13xuDA12AywCAEEXLJnn79WONC8I6uk6LBK4xx+Oj3Kqw7GBbtO9Fj1PXtJlmqQ/Wufdf692h4PefbKsytvLZQBECaG1TnU4MjB/3c/DICy4c09wSS4jS7RuymnJLLtbogXT2456nGhxZOCv0UWzQN5+7VK8uNS7J1eOcRMmtQs6CwAEx4y8MtZ2OyYTnHUhmfLea/Ibuz+mTGivZpJA796QjMrt4jPBoYE+2yjCCUccAAT+1ufW0YfsyABdiT2STkg6YeDa4YQDAGgSO3p55Mq5GwIOZ+KeD7bCSdtC8+Q9Ew82hgwMNoYM2CES9DES9BX2ECUFQ29gsDFkYLAxZGCwMWRgsDFkYLBhBPQ7TZTg6MD5fiCdVkMgdd8/+3MAmyR9H0S6MidIp9UggUUSDkC4Iugrt9GiPJM0QbhCoMmuzBHSaP0XYBkfLLhiquwAAAAASUVORK5CYII=",
	5: "data:image/png;base64,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",
	6: "data:image/png;base64,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",
	7: "data:image/png;base64,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",
	8: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAnCAYAAABJ0cukAAAACXBIWXMAAAsTAAALEwEAmpwYAAAENElEQVRYhe1ZXWgcVRg9Z2ay2/zUvkSwfwnJSuiDDyoBi6ZmExuoNC+CodD4JLXB2rjN1jbagmExCpIwmzQqpOIPCAr+IBoLhSzNtokUWksfLEhrd9KWNhGNtBVCNsnOfD4ku2w2G3cmY7MGe16Wvff7zvkOc+98d+8SLrGj94o3bqmdBJpFIAQ+K7079eZXoUdm3HLbgeaWIG6qb5F8DQBIAED7H+uKLABH3HLbgeKWgMQLdsbuFVwbgOChRUMiG1zz2oR7A3nGfQP5xn0D+caqN+C6kTlFfXj0WRE5DmLTcjkEcguClmjQd2LZBrZ1/7pZU5WDqf6bBgKKP2zooiT004Gqmxni/W6Kn+PnRqH0A9jkeAnVdo9u8YeNj1VVvQowkF2BJNBGS4v5deOjBXMiropPSYAbIULbT6A2PPooYQUh1m6Cqj0ReEC8CJE9IGX55S6NnAZqe2I1isV2QBoBAosWTH6R1UBHhyjD64ydQhyBcOt/reh0LDDQ1HHJM/HAmuYzinEY4JZ7JSrA74AcU4gBD83LJwNV07lyGrrGi6cZr1IVaQTQCuJBYN5AQ9d4sanFX5oQOej2DZET5DfatOyJvO676yRt8ND6SQAXAVzc0XulN25qnwCA5tdjOxOc+hRAqdOlIoIbJMqyTAiAayArMqeevlOxKxSi5e+5+gwspZ3EYwBKc2pBJik4DzJ8MlD5fUeHNEVJUUC8b5PAAvAzgA9gSXPCNMuiwcry+WIzYmENBX2VlpLYDFi7099AoRCtOt3opCgREg12tAGAYDFIP4Dv/LrxTihECwA0gkv0AolD+JMQIxAZESo/Rtsq7tgRS2K+iX2RPlbbE2uE4KgTnkyQeKNej509FfQNaCLyMokPBfASPAuREUvBSCHN83Y2l2NxYVvqi+AHVZFXIgd8N3Llbe+7vsGcNftBNM6lIghgQIsGfScArNhPQAiqk3tNLVBbIq3lY3bSIq3lY9v7rreYCfPW3AirgTycRglZmypqf9m4k9xIa/lYas8RJRBZav2vHqx6A64PCXV6zAIXHqlFxIwGfYuOKXW6MQyixq1mSgcYXuEnIE/9m2wUqVn1SyhvBkTkqJYoLAHE1h3qUvF5MzAzO9M3eGj9pFUw1ecmPm8GPB7Pq7XvXSpRZgtb3cSv+K1EEgQ7OVvU6Tb+/72J63Rjb2YPAOauVep0Y68bbrtYViNr+lLUiZvG2yDb/zlSjv9VdHv/hZbqWQDwh40zBLYtR3MJ/tOODTz57i9rvQXez5PH2pwSgsHEGnXXyL7y28mx9O49dKBCsXvlki3P8RLyFniHFhQvMiqQbgG20pInRKQLIqPJaRINBfHEqQWmwJm5Tzj6IzBbnuO3kFD+hOAyyG+pWF8PBR6+kBFyDsDhev3a4xas50l5DsRv6QEEuiEIkDjm5MIrW97fd1Of+s4MDIEAAAAASUVORK5CYII=",
	9: "data:image/png;base64,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",
	10: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFOElEQVRoge1YXWwUZRQ9ZxZpaEwoJsaoaNhuIYEor/jAzy5FA0FSBQsYhZoA4UVhdzYRJGohxuBD7RQfrGJ46IMJlMSARDAI+9OCmvhkIjFBdmpC0AewCAiVlp3jQ0vDtjOzu53RxoTzNt+9595zkvm+784QIWNpR+FZiWslLQIxEwAIXJTQK6A7b8ZOhdmPYRVqbCvMKRr4jORi/0zli9SWnmTDL2H0DcVAwrIXQzoCckZFBOkqgaaMGesN2juwgca2whzHwPcVix+BoH45zoJ8evaFIP2NIGQAKEbwSbXiAYDgQ6RxIGh/Nrf+NPVyXe0eSBtHlroevnZr9+E9Tw2WI49s2JNBBIjOslyy4XS5PC+dUy7X1e4hsBMcfZveujy9FgB2lW3ucF3Ql5DiWgBlDXjpNAi1jCtKvVZJc0ELqxHrgTKn1jC8dBoAH3VJd1lzK8rHK8nzhTizskR3nYE3cVAIcILwAxkQdCkIHwAYsEYgAyQDX0QAeoKQAxlwpENB+MNQdxB2IAN5M3ZKQGbiFZTPmg0B+KHcxMZmAFeq5Qnqdxxnc9D+gQ30bpvVR2m1oP5KOYL6DeGFoHMQEIIBAMiYsV6HegZSrlyuoKwcZ0EYkygATAmjCACMzPeJeMeFRoprISwC+MRwVBdB9EI6lAv4zo9FaAbuYmQwKzvbhIWyBpZYfXURYb2o37LJ6DGQ+lcVSUx09K2i+FiROJhPRf/0S/fdA8v3na8x5HwrqhPA0XiH3dXcrUiogu9Bc7ci8Q67C8BRUZ2Uc3b5vvM1fhxfA0OKzAc59+4zwQ1XLtkHWlsV+gzV2irjyiX7AMENo/3IeQNF42k/nr+QSI0N4EbpIlt6pvfthxTaDwFI7Jnetx9gS+kyrtdoqu1H9TVw+o2Zf0jYAGGoJEBsSlh2ZygmJCYsuxPEptJ1DAHYeDL9pO/94mkgbtk7ACBn1h8FnfUA7pQkkFvjlv1pIBMS41bfRyC3li6r6Igbc2b9UQCIt9utPgY04BagtDdu2VsBIJtq+ELAq5KKpR64JdFhWxPVn+iwLRKvjxUP8pV8OnoQABKW/TaJ3e4VNGAI/M41RhLQxwnrwssAkEvVHwLQMtYEwO0Jy26rWrxltwHcPk480DLSC/H2wi4A73lX4VmDKm4TcM01DBqQ0RVvL6wEgJwZ+xzAuy6p6UR74YOKxQ/npsf1I94Z6YFEe2Enyfe9aki4DhWTRtacfS4CrsC402bUxQMkDicse/Ew0XA/FcgdcatglhMf/7CQBrnDVRRoA0C83X4T5F6fMjcYKa7ImrPPjW7AJR2FhYbDEyAedOdoAOJxQI0g6zwK3ymC83tS0Z/dgkv3/TpPjvMjvCYA6aqIHwg+5yld+MsxtCKfjJ0B7jmF8snYGRArBd10Z3IaiDU+4gFgSgRO0rO346Q8xQMAOcNPvKCbEp6/K77EAABkU/U9hmOsknTLR6QvJDb6BJdNvK5uGY6xKpeuz9+7Pu4eyKSjWQFNXsdrBa28/ykRj0yoonCbUnMmHc2OjbleZHkzdopEE6C/q21GstYnOq3aegIGAa3JphuOu8U9b+JMMvYNxAmZCAsCBg3ppZwZ+8orx3cWypr1Jx3HeFHC7fDl+UPAIIHmjBk75pdXdizOp6NfG+R/a0IYErgum6r/slxqRXN9JhU9QTmrvW7sMCHgGsmmfCp6pJL8ij9MsumG40UZc8tnBkNRxtxMKnqi0vyqvqx6zVm/Vy+pOlTbY9J/rwfFfQOTjfsGJhv3DUw2/vcG/gEn4Sfa3kOf1wAAAABJRU5ErkJggg==",
	11: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADBklEQVRoge2ZTWhTWRiGn/eYabWOXQguxqp0qoioC0EZyoCmEcQBBWdhXQwKItKuRGOXLurGYWawiX+gFcGFunEjDAXbjb8VhNGVVkRJqtafjah00dZq7udCw6QhSZPQ1FPIuzqc7/3O+Z577r3n5EaUoZZY8k9Eh6Cm1FyDccHR69GmQ+XMna1QSyyxBdEt1JAxy0tJbdeiP1/NlSTYRxnFf8ut4Wv+lAA4oTMTiv86yyLDugtUccJgvJwJDcYxTpSTm7OUSDxp+YLXo00qZbBcY5U6RqlylRx8OlQF+N6a8QAFH+LplY2a6TWyF5h6AxdcuXVg2dPJsjwCyCGjJ+WCg4VA/L6FxFYXuAfh+ODufBa/AQCJWoedj8QTh3PFvQf4X+oMxxJ7s3tnEAAInQp3PV2W2TezAEStnDuS2TejAABktGauQqiQudIHsUw1d72YM9t93iDsGGhFXqMkx6zfgaPg0Qrc7VgyeiPa1De3bvZasMcFzWJzuukNQFo97Q0jQeCik9ga0w3vAADm/Vhzq1DczBam214C9LQ3jBSKS6pLtx3Gyzy+oSmtqkIKSWozs7OIRRn9Q0Ggtu9RUEsseUfi18l8kXjSMPqn7TVZrEo9HXv5DJSiKsCUy+gv3srtSpZSVVVVTZFaYol/IvHE37li3m1k2dp4LLHJAvoAJLcl+5O/1wC/HX9S/zEVGsg45gzVus+re/cvH057/NsHMjSWCv2VdUZbPJYKTfhN7O0KhLsGm+WCO0ITLrJhgYnwzQNL+8HTFejsNOcUnM4uHkDIuYCTmAk8BbhR/2wH0pq8BmlNJD7YCh7eQq2XbdbbV8mHBb9MAAZP7MPzVd6twNtXiR2TFQ8gWE5943bvAMy0q1ivc7bTOwDgl2KNZtbsHYCk4v9Al0LeAYANFG9lwDsAC7hQrFeyi94BLBgePYdxvwjrveG69+e82wcA1see/RRS8C+wLlfcjP9SuG23Dza+8RIAYG33vR/mjczfg9kfklYCmNkjoUvDc9+dv9++7hPAF0Z96GNzO74WAAAAAElFTkSuQmCC",
	12: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADiklEQVRogc1ZTU8TURQ9ZwbDD5AdSkIxLgyJ7HBHYWWiiQsxRCWRjRATv4q/wxZdCRtdFA2JCzUaXWFZqTsWxgWGIRFZGxMTUMscF7Sknc7Hm/bZ9uzmzX2957x3b++8+zhxf2tcjpYguQJzpfnMS3QxsnnvAqGCQNeBbnK84H0FcKLyvixgupTLrHSSZBSyBW+KQBFADwAI2nEguTU2PQSK2YI31RmK0QiSr6Ds+HTmAZRrBrtORBR5gredtdzgC1+6jIAISMtjC5vT7aXaiIkF71KQvKR9STPvc5lXrA5GqYzKiWx+8xyIRYoiObuaG3ybhpjJfBNOTnW0lMusCJiGYTgRfESwH8QxQYtpyJvMN11Qp3ZSKZdZMQ4n4ljN0/G0AuLmx4VNMBrqBADA2vzQ86AIki59PGlHTkwseJckPEWAPIBrpfmh5aB9gwCgcyLSkgciBADtF9EMeSBGAHAgIpjYJF1HfGyBcx2C5AGUQV6NIw8kCABiEts+EhM2DIkCgPBw+l8wCZtahK7kYZEB+62yMwBJF0BxvOAVDweF71HFLnQHDotMtyCmWBqFkAG2U88QvttwHL4D5GwKB9u+z9m0jm35YNhgKzj7YKN3z++Zo3RFxDAAUPgMcLnXLS+9u3Pyt01/VgVM3P/W7zt/3xA8HWogrVNHzq/eG9ix5dOagIOVdz9Fkq9CWu9198/Y2glbSYw9v2cukTwAkCN/5F635deaAABXTQ0lc9skWBNA4ZSxsThsy6/NHTCGAN/Wb1kTIOKLqS0pY9sk2AyhYrJVxZYw+lAzgTUBvW55CdJ6oqG0fvTH7pItv9YLmfj3NciRUIP/UMisJvHqvYGdvp+7o6RuAfoI4ReEX5I+kLrV93N31CZ5IGIHUp0HYr7V42DLR+vngVYbWy36sBVCrTa2moaN80A7EHkeCD0TV2Ktod0X0vqwDkn7cjCzdnfIqK4YhVC7yAPpm2eJArIFbyq06WQfDc0zk0uWWAFxXeJWmIah2UuWSAHN9iqbRbO92FAB7SZfRTMiGgR0inwVaUXUCYhM2LAucX2daLWxVTc/riseTOxDAWkv+WqKXauNrdD5pnd2BDofNnEYy29OOuQzBP8JK8WO2bx3gcRzGK58JxAZHcKkA+Bhw4suIg9EhxOovAOoq8lXES6CZYfkDQnfIG0BuNiN5Kso5TIrEiYFeQI2BM79A7D9dwIFdOgTAAAAAElFTkSuQmCC",
	13: "data:image/png;base64,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",
	14: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD3klEQVRoge2ZQWgcVRjH//+dyW4TaiqYeEkQOhWlRz16cfegBFpPprGFtAdzsFJqNi00QltLQ5FUMJtN8FCVoI2gzV4riD1kT8VbPQhCaHYRmksaxNradHdn5u8h7u402dnskqGzK/md9n3fN+/7f7Nv3ps3j2gD4p8vnyVxAcCNnn7rVGaITtkXCVFXw5BMgnwe5AdrK7nvjizIKPvaogAQ1z2No94i6I07fG2l6y/Hjj1bddvTtU4WWUqRPFG16oeePmu4UkBiajkN4DRI1uijJZH0lVlt8n0QbSMeAAgeqxQgapLiKCCz3kVhITJCYN8m6xdtccePLMhYu5f/BsRw1aovF5PWybaYhdZW8jNe8YJmF5PWSZBqiwIEHfL8ns0mrVGQAtplHRDOQ/gN0GWv+F12CQACQHwq9zOJt8IW0wwSbmXPWG9HAKDdxANVze0xC9Uh8AIErAq64IKvmXbnXtPu3Os4fB3ARQGrQecL9L1HQqZYKozcHj/4cJPrDoA7b1z9PR2LxuYADAaVM7ACJGSyY/vfq7fI3B4/+BDSUGI6v4CAighkCAlYLZYKIw2tkKRiEXsEwv0gctcsQEBRwrhhGn2GafQJ+FhA0b8bzdQYNr78NPrK3wBmfXtrIr/fEPoke8b6zNO+Gk/lAGCyVjBd3mxQewXH5U3D0MRO89f8BxxFrm+2qcRv/cS4scfL9eVuxXae3PXzNZO/ZgGxjq37YsMwjFqxAFD6x2h6Y9S9x/+aZvLXLMC2neObbWJpi61MR3TPAT+fH+tuh+Xnaya/3zMwEU/lYJrGPAA4JfuEyMt+tywCHQbw6zaan75GeqfOJ4SG8xMAEqncjjYIAlaLxcLLjc5EA+ml7oJj3gXRu5O8i2MWA1kHCLwYi8bmIG3/LEgsOObcTsWXCfJdaDAxnV8YSC91+wUMpJe6E6l8BsS7QSUN+hvQYMEx30xM5WaJyI9O9NFSdP0FOUbhVcE9VHDxEYieIBMG/xFrY2hMCO5EpNQF21wPPIWX/8d+QMKtsIU0Sztq3qUleXrhkZiYzl2SOAxiJjtmzYSkq2Gqs5DE+HQuDfASiQMELoaoq2E2CvhPPMHTHt+NcCQ1h1lLvISMHvyRDFNYozAxtTwJctxrFPCAkhuWqPrQBjGzOGZdAQAT4KktIcA+tPZh5TkAVwAgIuj7kMU0hSBXwNflttnbb324tpJ7DuBRT9B81O1IPu5Uy52E2Ot88svZlypviAQ2TgHv38vPkzjmif10ccw6/8wVNkkEADJDdHr79x+XUBlOkvdIs3WpLGTlIiBdE/QnoekwhTXKvx//eq77xCqaAAAAAElFTkSuQmCC",
	15: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClklEQVRoge2ZMVMTQQCF39uLpYW2kBkTkBb/AEOg0MLGcWAyjhRWoWQSLPwRwFFYAI0NOBOk0EothGT8A7aKhCIZO8ZR23DPRpy7S4DbkOMIc1+3d/d237vd272dJWKisHLwEMQ6RZEs7ZZz7+Nox8RRKQAQXCM4BGJY0Hpc7cQWAMSwr5SNq5n4AlwSaYCkSQMkTcZfmF4+nJLRBiRHYLlWyb9LypifSffwkZHngmzTY2l3Mbd3ci/QAzLaADAKMkdip+A2ipfuNkTBbRQN9AbkHQCjYnBNCQ4hyfGVMgQ2kwxRcBtFApvwjRQx4DEYwKOpAGj7LiUWopt5AG2IFf9zgQD1cu6tJz1BKASkrcnVg7n47AaZXm3Mdrx56VjSs/B32TEL1SsjOwLm4AtB0jHiK6ueEFq+UjOqrOA2ihJeI/zmyae1yshW+Pmu02itnK+GQ8ByOJEs/QvR9DyWoprvNmwEzNXK+WrXdnqqUJjp9xQ75X5/DJhqR1tnmAfOWchO6wlQKxez2w2+hKV5IMJK3D0E26cK+kMk80DEX4laOV+VMCOoIeCbwPmLewxCYV7SDwBND5yNYj4lJeUacOZCdhoTS/vZjHFcEPcB3Lyghz+QPoF8sVfOf7UVWweYWNrPOo75QvC2rfZMpJ9tzxv//Pxu5P8moIctZcZxVvpuHgDIW45xlm1lveyJH/Sgia3uq7WpJ2QrsQ4g4YOtxqL2j7YK+wBOuyLpyFZ3br3Skczxoq3OOkB9YaxldGNc0LaAX7b6MBJ+C9qWc3yvvjDWOl+RktJX+P8oCBxK2owVQotkKUNwDcBgmQdwcnRlQkdBg0b2aq3EPZAGSJo0QNKkAZLmGgQIHkQMGk3jO4gYNJqex9Jf29X9bgr5aTsAAAAASUVORK5CYII=",
	16: "data:image/png;base64,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",
	17: "data:image/png;base64,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",
	};

	const clusterNamesScale = d3.scaleOrdinal()
		.domain(["Food Security",
			"Health",
			"Emergency Shelter and NFI",
			"Water Sanitation Hygiene",
			"Protection",
			"Nutrition",
			"Logistics",
			"Education",
			"COVID-19",
			"Coordination and Support Services",
			"Camp Coordination / Management",
			"Early Recovery",
			"Multi-Sector",
			"Multi-purpose cash (not sector-specific)",
			"Multi-purpose CASH",
			"Emergency Telecommunications",
			"Mine Action",
			"To be determined",
			"Common and Support Services",
			"Multi-Purpose cash"
		])
		.range(["Food Security",
			"Health",
			"Shelter",
			"Water",
			"Protection",
			"Nutrition",
			"Logistics",
			"Education",
			"COVID-19",
			"Coordination",
			"Camp Coordination",
			"Early Recovery",
			"Multi-Sector",
			"Multi-purpose CASH",
			"Multi-purpose CASH",
			"Emergency Telecom.",
			"Mine Action",
			"To\u00a0be determined",
			"Common Services",
			"Multi-purpose CASH"
		]);

	let isSnapshotTooltipVisible = false,
		currentHoveredElement;

	const hardcodedAllocations = [{
		isoCode: "XX",
		long: 35.24,
		lat: 38.96
	}, {
		isoCode: "KM",
		long: 43.87,
		lat: -11.87
	}, {
		isoCode: "CV",
		long: -24.01,
		lat: 16
	}, {
		isoCode: "MH",
		long: 171.18,
		lat: 7.13
	}, {
		isoCode: "AG",
		long: -61.8,
		lat: 17.06
	}, {
		isoCode: "DM",
		long: -61.37,
		lat: 15.41
	}, {
		isoCode: "0V",
		long: -66.85,
		lat: 1.23
	}, {
		isoCode: "WS",
		long: -172.1,
		lat: -13.76
	}, {
		isoCode: "XA",
		long: 41.9,
		lat: 3.86
	}, {
		isoCode: globalIsoCode,
		long: -74,
		lat: 40.73
	}];

	const hardcodedRegionals = [41, 31, 110, 103];

	const queryStringValues = new URLSearchParams(location.search);

	if (!queryStringValues.has("viz")) queryStringValues.append("viz", vizNameQueryString);

	const containerDiv = d3.select("#d3chartcontainer" + classPrefix);

	const showHelp = containerDiv.node().getAttribute("data-showhelp") === "true";

	const showLink = containerDiv.node().getAttribute("data-showlink") === "true";

	const showNamesOption = queryStringValues.has("shownames") ? queryStringValues.get("shownames") === "true" : containerDiv.node().getAttribute("data-shownames") === "true";

	const chartTitle = containerDiv.node().getAttribute("data-title") ? containerDiv.node().getAttribute("data-title") : chartTitleDefault;

	const selectedResponsiveness = containerDiv.node().getAttribute("data-responsive") === "true";

	const lazyLoad = containerDiv.node().getAttribute("data-lazyload") === "true";

	const selectedYearString = queryStringValues.has("year") ? queryStringValues.get("year").replace(/\|/g, ",") : containerDiv.node().getAttribute("data-year");

	//improve this:
	// const selectedCerfAllocation = queryStringValues.has("cerfallocation") && cerfAllocationTypes.indexOf(queryStringValues.get("cerfallocation")) > -1 ? queryStringValues.get("cerfallocation") :
	// 	cerfAllocationTypes.indexOf(containerDiv.node().getAttribute("data-cerfallocation")) > -1 ?
	// 	containerDiv.node().getAttribute("data-cerfallocation") : "total";

	chartState.selectedCerfAllocation = "0";

	chartState.showNames = showNamesOption;

	if (selectedResponsiveness === false) {
		containerDiv.style("width", width + "px")
			.style("height", height + "px");
	};

	const topDiv = containerDiv.append("div")
		.attr("class", classPrefix + "TopDiv");

	const titleDiv = topDiv.append("div")
		.attr("class", classPrefix + "TitleDiv");

	const iconsDiv = topDiv.append("div")
		.attr("class", classPrefix + "IconsDiv d3chartIconsDiv");

	const svg = containerDiv.append("svg")
		.attr("viewBox", "0 0 " + width + " " + height)
		.style("background-color", "white");

	const yearsDescriptionDiv = containerDiv.append("div")
		.attr("class", classPrefix + "YearsDescriptionDiv");

	const stackedBarchartDiv = containerDiv.append("div")
		.attr("class", classPrefix + "stackedBarchartDiv");

	const stackedBarchartDivTitle = stackedBarchartDiv.append("div")
		.attr("class", classPrefix + "stackedBarchartDivTitle");

	stackedBarchartDivTitle.append("span")
		.html("By Agency");

	const stackedBarchartContainerDiv = stackedBarchartDiv.append("div")
		.attr("class", classPrefix + "stackedBarchartContainerDiv");

	const stackedSvg = stackedBarchartContainerDiv.append("svg")
		.attr("viewBox", "0 0 " + stackedSvgWidth + " " + stackedSvgHeight)
		.style("background-color", "white");

	const footerDiv = containerDiv.append("div")
		.attr("class", classPrefix + "FooterDiv");

	const snapshotTooltip = containerDiv.append("div")
		.attr("id", classPrefix + "SnapshotTooltip")
		.attr("class", classPrefix + "SnapshotContent")
		.style("display", "none")
		.on("mouseleave", function() {
			isSnapshotTooltipVisible = false;
			snapshotTooltip.style("display", "none");
			tooltip.style("display", "none");
		});

	snapshotTooltip.append("p")
		.attr("id", classPrefix + "SnapshotTooltipPdfText")
		.html("Download PDF")
		.on("click", function() {
			isSnapshotTooltipVisible = false;
			createSnapshot("pdf", true);
		});

	snapshotTooltip.append("p")
		.attr("id", classPrefix + "SnapshotTooltipPngText")
		.html("Download Image (PNG)")
		.on("click", function() {
			isSnapshotTooltipVisible = false;
			createSnapshot("png", true);
		});

	const browserHasSnapshotIssues = !isTouchScreenOnly && (window.safari || window.navigator.userAgent.indexOf("Edge") > -1);

	if (browserHasSnapshotIssues) {
		snapshotTooltip.append("p")
			.attr("id", classPrefix + "TooltipBestVisualizedText")
			.html("For best results use Chrome, Firefox, Opera or Chromium-based Edge.")
			.attr("pointer-events", "none")
			.style("cursor", "default");
	};

	const tooltip = containerDiv.append("div")
		.attr("id", classPrefix + "tooltipdiv")
		.style("display", "none");

	const tooltipBar = stackedBarchartContainerDiv.append("div")
		.attr("id", classPrefix + "tooltipdivBar")
		.style("display", "none");

	containerDiv.on("contextmenu", function() {
		d3.event.preventDefault();
		const thisMouse = d3.mouse(this);
		isSnapshotTooltipVisible = true;
		snapshotTooltip.style("display", "block")
			.style("top", thisMouse[1] - 4 + "px")
			.style("left", thisMouse[0] - 4 + "px");
	});

	const topPanel = {
		main: svg.append("g")
			.attr("class", "covmaptopPanel")
			.attr("transform", "translate(" + padding[3] + "," + padding[0] + ")"),
		width: width - padding[1] - padding[3],
		height: topPanelHeight,
		padding: [0, 0, 0, 0],
		moneyBagPadding: 4,
		leftPadding: [180, 395, 710, 926, 1010],
		mainValueVerPadding: 12,
		mainValueHorPadding: 1,
		linePadding: 8
	};

	const buttonsPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "buttonsPanel")
			.attr("transform", "translate(" + padding[3] + "," + (padding[0] + topPanel.height + panelHorizontalPadding) + ")"),
		width: width - padding[1] - padding[3],
		height: buttonsPanelHeight,
		padding: [0, 0, 0, 0],
		buttonWidth: 54,
		buttonsMargin: 4,
		buttonsPadding: 6,
		buttonVerticalPadding: 4,
		arrowPadding: 18,
		cerfButtonsMargin: 546,
	};

	const mapPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "mapPanel")
			.attr("transform", "translate(" + padding[3] + "," + (padding[0] + topPanel.height + buttonsPanel.height + (2 * panelHorizontalPadding)) + ")"),
		width: width - padding[1] - padding[3],
		height: mapPanelHeight,
		padding: [0, 0, 0, 0],
	};

	const legendPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "legendPanel")
			.attr("transform", "translate(" + (padding[3] + legendPanelHorPadding) + "," + (padding[0] + topPanel.height + buttonsPanel.height + panelHorizontalPadding + mapPanel.height - legendPanelHeight - legendPanelVertPadding) + ")"),
		width: legendPanelWidth,
		height: legendPanelHeight,
		padding: [20, 0, 12, 4],
	};

	const mapZoomButtonPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "mapZoomButtonPanel")
			.attr("transform", "translate(" + (padding[3] + mapZoomButtonHorPadding) + "," + (padding[0] + topPanel.height + buttonsPanel.height + panelHorizontalPadding + mapZoomButtonVertPadding) + ")"),
		width: mapZoomButtonSize,
		height: mapZoomButtonSize * 2,
		padding: [4, 4, 4, 4],
	};

	const checkboxesPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "checkboxesPanel")
			.attr("transform", "translate(" + (padding[3] + mapZoomButtonHorPadding + 1) + "," + (padding[0] + topPanel.height + buttonsPanel.height + (2 * panelHorizontalPadding) + mapZoomButtonVertPadding + mapZoomButtonPanel.height + showNamesMargin) + ")"),
		padding: [0, 0, 0, 0],
	};

	const mapPanelClip = mapPanel.main.append("clipPath")
		.attr("id", classPrefix + "mapPanelClip")
		.append("rect")
		.attr("width", mapPanel.width)
		.attr("height", mapPanel.height);

	mapPanel.main.attr("clip-path", "url(#" + classPrefix + "mapPanelClip)");

	const zoomLayer = mapPanel.main.append("g")
		.attr("class", classPrefix + "zoomLayer")
		.style("opacity", 0)
		.attr("cursor", "move")
		.attr("pointer-events", "all");

	const zoomRectangle = zoomLayer.append("rect")
		.attr("width", mapPanel.width)
		.attr("height", mapPanel.height);

	const mapContainer = mapPanel.main.append("g")
		.attr("class", classPrefix + "mapContainer");

	const piesContainer = mapPanel.main.append("g")
		.attr("class", classPrefix + "piesContainer");

	const mapProjection = d3.geoEqualEarth();

	const mapPath = d3.geoPath()
		.projection(mapProjection);

	const radiusScale = d3.scaleSqrt()
		.range([minPieSize, maxPieSize]);

	const xScaleBar = d3.scaleBand()
		.paddingInner(0.4)
		.paddingOuter(0.2);

	const yScaleBar = d3.scaleLinear()
		.range([stackedSvgHeight - stackedPadding[2], stackedPadding[0]]);

	const xAxisBar = d3.axisBottom(xScaleBar)
		.tickSizeInner(0)
		.tickSizeOuter(0)
		.tickPadding(6);

	const xAxisBarGroup = stackedSvg.append("g")
		.attr("class", classPrefix + "xAxisBarGroup")
		.attr("transform", "translate(0," + (stackedSvgHeight - stackedPadding[2]) + ")");

	const stackKeys = cerfTypeKeys.map(e => `cerf${separator}${e}`);

	const stack = d3.stack()
		.keys(stackKeys)
		.order(d3.stackOrderDescending);

	const colors = d3.range(0.1, 1.1, 0.1).map(function(d) {
		return colorInterpolatorTotal(d);
	});

	const colorScale = d3.scaleQuantile()
		.range(colors);

	const arcGenerator = d3.arc()
		.innerRadius(0);

	const arcGeneratorEnter = d3.arc()
		.innerRadius(0)
		.outerRadius(0);

	const pieGenerator = d3.pie()
		.value(function(d) {
			return d.value;
		})
		.sort(null);

	const zoom = d3.zoom()
		.scaleExtent([1, 20])
		.extent([
			[0, 0],
			[mapPanel.width, mapPanel.height]
		])
		.translateExtent([
			[0, 0],
			[mapPanel.width, mapPanel.height]
		]);

	mapPanel.main.call(zoom);

	const defs = svg.append("defs");

	const filter = defs.append("filter")
		.attr("id", classPrefix + "dropshadow")
		.attr('filterUnits', 'userSpaceOnUse');

	filter.append("feGaussianBlur")
		.attr("in", "SourceAlpha")
		.attr("stdDeviation", 3);

	filter.append("feOffset")
		.attr("dx", 0)
		.attr("dy", 0);

	const feComponent = filter.append("feComponentTransfer");

	feComponent.append("feFuncA")
		.attr("type", "linear")
		.attr("slope", 0.7);

	const feMerge = filter.append("feMerge");

	feMerge.append("feMergeNode");
	feMerge.append("feMergeNode")
		.attr("in", "SourceGraphic");

	mapZoomButtonPanel.main.style("filter", "url(#" + classPrefix + "dropshadow)");

	const tooltipSvgYScale = d3.scalePoint()
		.range([tooltipSvgPadding[0], tooltipSvgHeight - tooltipSvgPadding[2]])
		.padding(0.5);

	const tooltipSvgXScale = d3.scaleLinear()
		.range([tooltipSvgPadding[3], tooltipSvgWidth - tooltipSvgPadding[1]]);

	const tooltipSvgYAxis = d3.axisLeft(tooltipSvgYScale)
		.tickSize(0)
		.tickPadding(5);

	const tooltipSvgXAxis = d3.axisTop(tooltipSvgXScale)
		.tickSizeOuter(0)
		.tickSizeInner(-(tooltipSvgHeight - tooltipSvgPadding[0] - tooltipSvgPadding[2]))
		.ticks(3)
		.tickPadding(4)
		.tickFormat(function(d) {
			return "$" + formatSIaxes(d).replace("G", "B");
		});

	Promise.all([fetchFile("unworldmap", mapUrl, "world map", "json"),
			fetchFile("masterFunds", masterFundsUrl, "master table for funds", "json"),
			fetchFile("masterAllocationTypes", masterAllocationTypesUrl, "master table for allocation types", "json"),
			fetchFile("masterUnAgenciesTypes", masterUnAgenciesUrl, "master table for un agencies", "json"),
			fetchFile("masterPartnerTypes", masterPartnerTypesUrl, "master table for partner types", "json"),
			fetchFile("masterClusterTypes", masterClusterTypesUrl, "master table for cluster types", "json"),
			fetchFile("allocoverData", dataUrl, "allocations data", "csv")
		])
		.then(rawData => csvCallback(rawData));

	function fetchFile(fileName, url, warningString, method) {
		if (localStorage.getItem(fileName) &&
			JSON.parse(localStorage.getItem(fileName)).timestamp > (currentDate.getTime() - localStorageTime)) {
			const fetchedData = method === "csv" ? d3.csvParse(JSON.parse(localStorage.getItem(fileName)).data, d3.autoType) :
				JSON.parse(localStorage.getItem(fileName)).data;
			console.info("CERF BI chart info: " + warningString + " from local storage");
			return Promise.resolve(fetchedData);
		} else {
			const fetchMethod = method === "csv" ? d3.csv : d3.json;
			const rowFunction = method === "csv" ? d3.autoType : null;
			return fetchMethod(url, rowFunction).then(fetchedData => {
				try {
					localStorage.setItem(fileName, JSON.stringify({
						data: method === "csv" ? d3.csvFormat(fetchedData) : fetchedData,
						timestamp: currentDate.getTime()
					}));
				} catch (error) {
					console.info("CERF BI chart, " + error);
				};
				console.info("CERF BI chart info: " + warningString + " from API");
				return fetchedData;
			});
		};
	};

	function csvCallback([mapData,
		masterFunds,
		masterAllocationTypes,
		masterUnAgenciesTypes,
		masterPartnerTypes,
		masterClusterTypes,
		rawData
	]) {

		preProcessData(rawData);
		validateYear(selectedYearString);
		createFundNamesList(masterFunds);
		createUnAgenciesNamesList(masterUnAgenciesTypes);
		createPartnersList(masterPartnerTypes);
		createClustersList(masterClusterTypes);
		createAllocationTypesList(masterAllocationTypes);

		cerfAllocationTypes["0"] = "Total";

		if (!lazyLoad) {
			draw(rawData, mapData);
		} else {
			d3.select(window).on("scroll." + classPrefix, checkPosition);
			d3.select("body").on("d3ChartsYear." + classPrefix, function() {
				chartState.selectedYear = [validateCustomEventYear(+d3.event.detail)]
			});
			checkPosition();
		};

		function checkPosition() {
			const containerPosition = containerDiv.node().getBoundingClientRect();
			if (!(containerPosition.bottom < 0 || containerPosition.top - windowHeight > 0)) {
				d3.select(window).on("scroll." + classPrefix, null);
				draw(rawData, mapData);
			};
		};

		//end of csvCallback
	};

	function draw(rawData, mapData) {

		const data = processData(rawData);

		createTitle(rawData);

		createButtonsPanel(rawData);

		createMap(mapData);

		verifyCentroids(data.map);

		createZoomButtons();

		createCheckboxes();

		createTopPanel(data);

		createChoropleth(data);

		createLegend(data);

		createFooterDiv();

		createStackedBar(data);

		if (showHelp) createAnnotationsDiv();

		//end of draw
	};

	function createTitle(rawData) {

		const title = titleDiv.append("p")
			.attr("id", classPrefix + "d3chartTitle")
			.html(chartTitle);

		//NO HELP ICON FOR NOW
		// const helpIcon = iconsDiv.append("button")
		// 	.attr("id", classPrefix + "HelpButton");

		// helpIcon.html("HELP  ")
		// 	.append("span")
		// 	.attr("class", "fa fa-info")

		const downloadIcon = iconsDiv.append("button")
			.attr("id", classPrefix + "DownloadButton");

		downloadIcon.html(".CSV  ")
			.append("span")
			.attr("class", "fa fa-download");

		const snapshotDiv = iconsDiv.append("div")
			.attr("class", classPrefix + "SnapshotDiv");

		const snapshotIcon = snapshotDiv.append("button")
			.attr("id", classPrefix + "SnapshotButton");

		snapshotIcon.html("IMAGE ")
			.append("span")
			.attr("class", "fa fa-camera");

		const snapshotContent = snapshotDiv.append("div")
			.attr("class", classPrefix + "SnapshotContent");

		const pdfSpan = snapshotContent.append("p")
			.attr("id", classPrefix + "SnapshotPdfText")
			.html("Download PDF")
			.on("click", function() {
				createSnapshot("pdf", false);
			});

		const pngSpan = snapshotContent.append("p")
			.attr("id", classPrefix + "SnapshotPngText")
			.html("Download Image (PNG)")
			.on("click", function() {
				createSnapshot("png", false);
			});

		const playIcon = iconsDiv.append("button")
			.datum({
				clicked: false
			})
			.attr("id", classPrefix + "PlayButton");

		playIcon.html("PLAY  ")
			.append("span")
			.attr("class", "fa fa-play");

		playIcon.on("click", function(d) {
			d.clicked = !d.clicked;

			playIcon.html(d.clicked ? "PAUSE " : "PLAY  ")
				.append("span")
				.attr("class", d.clicked ? "fa fa-pause" : "fa fa-play");

			if (d.clicked) {
				chartState.selectedYear.length = 1;
				loopButtons();
				timer = d3.interval(loopButtons, 3 * duration);
			} else {
				timer.stop();
			};

			function loopButtons() {
				const index = yearsArray.indexOf(chartState.selectedYear[0]);

				chartState.selectedYear[0] = yearsArray[(index + 1) % yearsArray.length];

				const yearButton = d3.selectAll("." + classPrefix + "buttonsRects")
					.filter(function(d) {
						return d === chartState.selectedYear[0]
					});

				yearButton.dispatch("click");

				if (yearsArray.length > buttonsNumber) {

					const firstYearIndex = chartState.selectedYear[0] < yearsArray[buttonsNumber / 2] ?
						0 :
						chartState.selectedYear[0] > yearsArray[yearsArray.length - (buttonsNumber / 2)] ?
						yearsArray.length - buttonsNumber :
						yearsArray.indexOf(chartState.selectedYear[0]) - (buttonsNumber / 2);

					const currentTranslate = -(buttonsPanel.buttonWidth * firstYearIndex);

					if (currentTranslate === 0) {
						svg.select("." + classPrefix + "LeftArrowGroup").select("text").style("fill", "#ccc")
						svg.select("." + classPrefix + "LeftArrowGroup").attr("pointer-events", "none");
					} else {
						svg.select("." + classPrefix + "LeftArrowGroup").select("text").style("fill", "#666")
						svg.select("." + classPrefix + "LeftArrowGroup").attr("pointer-events", "all");
					};

					if (Math.abs(currentTranslate) >= ((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth)) {
						svg.select("." + classPrefix + "RightArrowGroup").select("text").style("fill", "#ccc")
						svg.select("." + classPrefix + "RightArrowGroup").attr("pointer-events", "none");
					} else {
						svg.select("." + classPrefix + "RightArrowGroup").select("text").style("fill", "#666")
						svg.select("." + classPrefix + "RightArrowGroup").attr("pointer-events", "all");
					};

					svg.select("." + classPrefix + "buttonsGroup").transition()
						.duration(duration)
						.attrTween("transform", function() {
							return d3.interpolateString(this.getAttribute("transform"), "translate(" + currentTranslate + ",0)");
						});
				};
			};
		});

		if (!isBookmarkPage) {

			const shareIcon = iconsDiv.append("button")
				.attr("id", classPrefix + "ShareButton");

			shareIcon.html("SHARE  ")
				.append("span")
				.attr("class", "fa fa-share");

			const shareDiv = containerDiv.append("div")
				.attr("class", "d3chartShareDiv")
				.style("display", "none");

			shareIcon.on("mouseover", function() {
					shareDiv.html("Click to copy")
						.style("display", "block");
					const thisBox = this.getBoundingClientRect();
					const containerBox = containerDiv.node().getBoundingClientRect();
					const shareBox = shareDiv.node().getBoundingClientRect();
					const thisOffsetTop = thisBox.top - containerBox.top - (shareBox.height - thisBox.height) / 2;
					const thisOffsetLeft = thisBox.left - containerBox.left - shareBox.width - 12;
					shareDiv.style("top", thisOffsetTop + "px")
						.style("left", thisOffsetLeft + "20px");
				}).on("mouseout", function() {
					shareDiv.style("display", "none");
				})
				.on("click", function() {

					const newURL = bookmarkSite + queryStringValues.toString();

					const shareInput = shareDiv.append("input")
						.attr("type", "text")
						.attr("readonly", true)
						.attr("spellcheck", "false")
						.property("value", newURL);

					shareInput.node().select();

					document.execCommand("copy");

					shareDiv.html("Copied!");

					const thisBox = this.getBoundingClientRect();
					const containerBox = containerDiv.node().getBoundingClientRect();
					const shareBox = shareDiv.node().getBoundingClientRect();
					const thisOffsetLeft = thisBox.left - containerBox.left - shareBox.width - 12;
					shareDiv.style("left", thisOffsetLeft + "20px");

				});

		};

		if (browserHasSnapshotIssues) {
			const bestVisualizedSpan = snapshotContent.append("p")
				.attr("id", classPrefix + "BestVisualizedText")
				.html("For best results use Chrome, Firefox, Opera or Chromium-based Edge.")
				.attr("pointer-events", "none")
				.style("cursor", "default");
		};

		snapshotDiv.on("mouseover", function() {
			snapshotContent.style("display", "block")
		}).on("mouseout", function() {
			snapshotContent.style("display", "none")
		});

		//helpIcon.on("click", null); //CHANGE THIS

		downloadIcon.on("click", function() {

			const csv = createCsv(rawData);

			const currentDate = new Date();

			const fileName = vizNameQueryString + "_" + csvDateFormat(currentDate) + ".csv";

			const blob = new Blob([csv], {
				type: 'text/csv;charset=utf-8;'
			});

			if (navigator.msSaveBlob) {
				navigator.msSaveBlob(blob, filename);
			} else {

				const link = document.createElement("a");

				if (link.download !== undefined) {

					const url = URL.createObjectURL(blob);

					link.setAttribute("href", url);
					link.setAttribute("download", fileName);
					link.style = "visibility:hidden";

					document.body.appendChild(link);

					link.click();

					document.body.removeChild(link);

				};
			};

		});

		//end of createTitle
	};

	function createMap(mapData) {

		const mergedoPt = topojson.merge(mapData, mapData.objects.wrl_polbnda_int_simple_uncs.geometries.filter(d => d.properties.ISO_2 === "PS"));

		const countryFeatures = topojson.feature(mapData, mapData.objects.wrl_polbnda_int_simple_uncs);

		countryFeatures.features = countryFeatures.features.filter(d => d.properties.ISO_2 !== "AQ" && d.properties.Terr_Name !== "Gaza Strip");

		const oPt = countryFeatures.features.find(d => d.properties.ISO_2 === "PS");

		oPt.geometry = mergedoPt;

		mapProjection.fitExtent([
			[mapPanel.padding[3], mapPanel.padding[0]],
			[(mapPanel.width - mapPanel.padding[1] - mapPanel.padding[3]), (mapPanel.height - mapPanel.padding[0] - mapPanel.padding[2])]
		], countryFeatures);

		const paths = mapContainer.selectAll(null)
			.data(countryFeatures.features)
			.enter()
			.append("path")
			.attr("d", mapPath)
			.attr("class", classPrefix + "MapPath")
			.style("fill", countriesBackground);

		const borders = mapContainer.append("path")
			.attr("d", mapPath(topojson.mesh(mapData, mapData.objects.wrl_polbnda_int_simple_uncs, (a, b) => a !== b)))
			.attr("class", classPrefix + "Border")
			.style("fill", "none")
			.style("stroke", "#C5C5C5")
			.style("stroke-width", "1px");

		const cerfCircle = mapContainer.append("circle")
			.datum({
				properties: {
					ISO_2: globalIsoCode
				}
			})
			.attr("class", classPrefix + "MapPath")
			.attr("cx", function() {
				const globalCerf = hardcodedAllocations.find(function(e) {
					return e.isoCode === globalIsoCode
				});
				return mapProjection([globalCerf.long, globalCerf.lat])[0]
			})
			.attr("cy", function() {
				const globalCerf = hardcodedAllocations.find(function(e) {
					return e.isoCode === globalIsoCode
				});
				return mapProjection([globalCerf.long, globalCerf.lat])[1]
			})
			.attr("r", cerfCircleRadius)
			.style("fill", countriesBackground)
			.style("stroke", "#C5C5C5")
			.style("stroke-width", "1px");

		const cerfText = mapContainer.append("text")
			.attr("class", classPrefix + "CerfText")
			.attr("x", function() {
				const globalCerf = hardcodedAllocations.find(function(e) {
					return e.isoCode === globalIsoCode;
				});
				return mapProjection([globalCerf.long, globalCerf.lat])[0]
			})
			.attr("y", function() {
				const globalCerf = hardcodedAllocations.find(function(e) {
					return e.isoCode === globalIsoCode;
				});
				return mapProjection([globalCerf.long, globalCerf.lat])[1] + cerfCircleRadius + 8;
			})
			.text("CERF Global");

		countryFeatures.features.forEach(function(d) {
			centroids[d.properties.ISO_2] = {
				x: mapPath.centroid(d.geometry)[0],
				y: mapPath.centroid(d.geometry)[1]
			}
		});

		// centroids.XX = centroids.TR;

		//Countries with problems:
		//"KM","WS","AG","DM","MH","CV"
		//Comoros, (west) Samoa, Antigua and Barbuda, Dominica, Marshall Islands, Cabo Verde
		//And the fake codes: XV, XA and XG
		hardcodedAllocations.forEach(function(d) {
			const projected = mapProjection([d.long, d.lat]);
			centroids[d.isoCode] = {
				x: projected[0],
				y: projected[1]
			};
		});

		//end of createMap
	};

	function createZoomButtons() {

		const zoomInGroup = mapZoomButtonPanel.main.append("g")
			.attr("class", classPrefix + "zoomInGroup")
			.attr("cursor", "pointer");

		const zoomInPath = zoomInGroup.append("path")
			.attr("class", classPrefix + "zoomPath")
			.attr("d", function() {
				const drawPath = d3.path();
				drawPath.moveTo(0, mapZoomButtonPanel.height / 2);
				drawPath.lineTo(0, mapZoomButtonPanel.padding[0]);
				drawPath.quadraticCurveTo(0, 0, mapZoomButtonPanel.padding[0], 0);
				drawPath.lineTo(mapZoomButtonPanel.width - mapZoomButtonPanel.padding[1], 0);
				drawPath.quadraticCurveTo(mapZoomButtonPanel.width, 0, mapZoomButtonPanel.width, mapZoomButtonPanel.padding[1]);
				drawPath.lineTo(mapZoomButtonPanel.width, mapZoomButtonPanel.height / 2);
				drawPath.closePath();
				return drawPath.toString();
			});

		const zoomInText = zoomInGroup.append("text")
			.attr("class", classPrefix + "zoomText")
			.attr("text-anchor", "middle")
			.attr("x", mapZoomButtonPanel.width / 2)
			.attr("y", (mapZoomButtonPanel.height / 4) + 7)
			.text("+");

		const zoomOutGroup = mapZoomButtonPanel.main.append("g")
			.attr("class", classPrefix + "zoomOutGroup")
			.attr("cursor", "pointer");

		const zoomOutPath = zoomOutGroup.append("path")
			.attr("class", classPrefix + "zoomPath")
			.attr("d", function() {
				const drawPath = d3.path();
				drawPath.moveTo(0, mapZoomButtonPanel.height / 2);
				drawPath.lineTo(0, mapZoomButtonPanel.height - mapZoomButtonPanel.padding[3]);
				drawPath.quadraticCurveTo(0, mapZoomButtonPanel.height, mapZoomButtonPanel.padding[3], mapZoomButtonPanel.height);
				drawPath.lineTo(mapZoomButtonPanel.width - mapZoomButtonPanel.padding[2], mapZoomButtonPanel.height);
				drawPath.quadraticCurveTo(mapZoomButtonPanel.width, mapZoomButtonPanel.height, mapZoomButtonPanel.width, mapZoomButtonPanel.height - mapZoomButtonPanel.padding[2]);
				drawPath.lineTo(mapZoomButtonPanel.width, mapZoomButtonPanel.height / 2);
				drawPath.closePath();
				return drawPath.toString();
			});

		const zoomOutText = zoomOutGroup.append("text")
			.attr("class", classPrefix + "zoomText")
			.attr("text-anchor", "middle")
			.attr("x", mapZoomButtonPanel.width / 2)
			.attr("y", (3 * mapZoomButtonPanel.height / 4) + 7)
			.text("−");

		const zoomLine = mapZoomButtonPanel.main.append("line")
			.attr("x1", 0)
			.attr("x2", mapZoomButtonPanel.width)
			.attr("y1", mapZoomButtonPanel.height / 2)
			.attr("y2", mapZoomButtonPanel.height / 2)
			.style("stroke", "#ccc")
			.style("stroke-width", "1px");

		//end of createZoomButtons
	};

	function createCheckboxes() {

		const showNamesGroup = checkboxesPanel.main.append("g")
			.attr("class", classPrefix + "showNamesGroup")
			.attr("cursor", "pointer");

		const outerRectangle = showNamesGroup.append("rect")
			.attr("width", 14)
			.attr("height", 14)
			.attr("rx", 2)
			.attr("ry", 2)
			.attr("fill", "white")
			.attr("stroke", "darkslategray");

		const innerCheck = showNamesGroup.append("polyline")
			.style("stroke-width", "2px")
			.attr("points", "3,7 6,10 11,3")
			.style("fill", "none")
			.style("stroke", chartState.showNames ? "darkslategray" : "white");

		const showNamesText = showNamesGroup.append("text")
			.attr("class", classPrefix + "showNamesText")
			.attr("x", 16)
			.attr("y", 11)
			.style("stroke", "white")
			.style("stroke-width", "2px")
			.style("paint-order", "stroke")
			.text("Show All");

		showNamesGroup.on("click", function() {

			chartState.showNames = !chartState.showNames;

			if (queryStringValues.has("shownames")) {
				queryStringValues.set("shownames", chartState.showNames);
			} else {
				queryStringValues.append("shownames", chartState.showNames);
			};

			innerCheck.style("stroke", chartState.showNames ? "darkslategray" : "white");

			const allLabels = mapContainer.selectAll("." + classPrefix + "countryNames");

			allLabels.style("display", null);

			if (!chartState.showNames) displayLabels(allLabels);

		});

		//end of createCheckboxes
	};

	function createTopPanel(data) {

		let mainValue = 0,
			rapidResponseValue = 0,
			underfundedValue = 0,
			numberofCountries = 0,
			numberofRegionals = 0,
			thisOffset;

		for (row of data.map) {
			mainValue += row[`cerf${separator}0${separator}0`];
			rapidResponseValue += row[`cerf${separator}3${separator}0`];
			underfundedValue += row[`cerf${separator}4${separator}0`];
			if (row[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`]) {
				if (hardcodedRegionals.includes(row.id)) {
					++numberofRegionals;
				} else {
					++numberofCountries;
				};
			};
		};

		const topPanelMoneyBag = topPanel.main.selectAll("." + classPrefix + "topPanelMoneyBag")
			.data([true])
			.enter()
			.append("g")
			.attr("class", classPrefix + "topPanelMoneyBag contributionColorFill")
			.attr("transform", "translate(" + topPanel.moneyBagPadding + ",6) scale(0.5)")
			.each(function(_, i, n) {
				moneyBagdAttribute.forEach(function(d) {
					d3.select(n[i]).append("path")
						.attr("d", d);
				});
			});

		const previousMainValue = d3.select("." + classPrefix + "topPanelMainValue").size() !== 0 ? d3.select("." + classPrefix + "topPanelMainValue").datum() : 0;
		const previousRapidResponseValue = d3.select("." + classPrefix + "topPanelRapidResponseValue").size() !== 0 ? d3.select("." + classPrefix + "topPanelRapidResponseValue").datum() : 0;
		const previousUnderfundedValue = d3.select("." + classPrefix + "topPanelUnderfundedValue").size() !== 0 ? d3.select("." + classPrefix + "topPanelUnderfundedValue").datum() : 0;
		const previousCountriesValue = d3.select("." + classPrefix + "topPanelCountriesValue").size() !== 0 ? d3.select("." + classPrefix + "topPanelCountriesValue").datum() : 0;
		const previousRegionalsValue = d3.select("." + classPrefix + "topPanelRegionalsValue").size() !== 0 ? d3.select("." + classPrefix + "topPanelRegionalsValue").datum() : 0;

		let mainValueGroup = topPanel.main.selectAll("." + classPrefix + "mainValueGroup")
			.data([true]);

		mainValueGroup = mainValueGroup.enter()
			.append("g")
			.attr("class", classPrefix + "mainValueGroup")
			.merge(mainValueGroup);

		let topPanelMainValue = mainValueGroup.selectAll("." + classPrefix + "topPanelMainValue")
			.data([mainValue]);

		topPanelMainValue = topPanelMainValue.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelMainValue contributionColorFill")
			.attr("text-anchor", "end")
			.merge(topPanelMainValue)
			.attr("y", topPanel.height / 2)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[0] - topPanel.mainValueHorPadding);

		topPanelMainValue.transition()
			.duration(duration)
			.tween("text", function(d) {
				const node = this;
				const i = d3.interpolate(previousMainValue, d);
				return function(t) {
					const siString = formatSIFloat(i(t))
					node.textContent = "$" + (+siString === +siString ? siString : siString.substring(0, siString.length - 1));
				};
			});

		let topPanelMainText = mainValueGroup.selectAll("." + classPrefix + "topPanelMainText")
			.data([mainValue]);

		topPanelMainText = topPanelMainText.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelMainText")
			.style("opacity", 0)
			.attr("text-anchor", "start")
			.merge(topPanelMainText)
			.attr("y", topPanel.height - topPanel.mainValueVerPadding * 2.7)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[0] + topPanel.mainValueHorPadding);

		topPanelMainText.transition()
			.duration(duration)
			.style("opacity", 1)
			.text(function(d) {
				const valueSI = formatSIFloat(d);
				const unit = valueSI[valueSI.length - 1];
				return (unit === "k" ? "Thousand" : unit === "M" ? "Million" : unit === "B" ? "Billion" : "") +
					" allocated";
			});

		let topPanelSubText = mainValueGroup.selectAll("." + classPrefix + "topPanelSubText")
			.data([true]);

		topPanelSubText = topPanelSubText.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelSubText")
			.style("opacity", 0)
			.attr("text-anchor", "start")
			.merge(topPanelSubText)
			.attr("y", topPanel.height - topPanel.mainValueVerPadding * 1.2)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[0] + topPanel.mainValueHorPadding);

		topPanelSubText.transition()
			.duration(duration)
			.style("opacity", 1)
			.text(function(d) {
				const yearsText = chartState.selectedYear.length === 1 ? chartState.selectedYear[0] : "selected years\u002A";
				return "in " + yearsText;
			});

		let topPanelRapidResponseValue = mainValueGroup.selectAll("." + classPrefix + "topPanelRapidResponseValue")
			.data([rapidResponseValue]);

		topPanelRapidResponseValue = topPanelRapidResponseValue.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelRapidResponseValue contributionColorFill")
			.attr("text-anchor", "end")
			.merge(topPanelRapidResponseValue)
			.attr("y", topPanel.height * 0.33)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[1] - topPanel.mainValueHorPadding);

		topPanelRapidResponseValue.transition()
			.duration(duration)
			.tween("text", function(d) {
				const node = this;
				const i = d3.interpolate(previousRapidResponseValue, d);
				return function(t) {
					node.textContent = "$" + formatSIFloat(i(t));
				};
			});

		const topPanelRapidResponseText = mainValueGroup.selectAll("." + classPrefix + "topPanelRapidResponseText")
			.data([true])
			.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelRapidResponseText")
			.attr("text-anchor", "start")
			.attr("y", topPanel.height * 0.33)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[1] + topPanel.mainValueHorPadding)
			.text("Rapid Response");

		let topPanelUnderfundedValue = mainValueGroup.selectAll("." + classPrefix + "topPanelUnderfundedValue")
			.data([underfundedValue]);

		topPanelUnderfundedValue = topPanelUnderfundedValue.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelUnderfundedValue contributionColorFill")
			.attr("text-anchor", "end")
			.merge(topPanelUnderfundedValue)
			.attr("y", topPanel.height * 0.67)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[1] - topPanel.mainValueHorPadding);

		topPanelUnderfundedValue.transition()
			.duration(duration)
			.tween("text", function(d) {
				const node = this;
				const i = d3.interpolate(previousUnderfundedValue, d);
				return function(t) {
					node.textContent = "$" + formatSIFloat(i(t));
				};
			});

		const topPanelUnderfundedText = mainValueGroup.selectAll("." + classPrefix + "topPanelUnderfundedText")
			.data([true])
			.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelUnderfundedText")
			.attr("text-anchor", "start")
			.attr("y", topPanel.height * 0.67)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[1] + topPanel.mainValueHorPadding)
			.text("Underfunded");

		let topPanelCountriesValue = mainValueGroup.selectAll("." + classPrefix + "topPanelCountriesValue")
			.data([numberofCountries]);

		topPanelCountriesValue = topPanelCountriesValue.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelCountriesValue contributionColorFill")
			.attr("text-anchor", "end")
			.merge(topPanelCountriesValue)
			.attr("y", topPanel.height / 2)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[2] - topPanel.mainValueHorPadding);

		topPanelCountriesValue.transition()
			.duration(duration)
			.tween("text", function(d) {
				const node = this;
				const i = d3.interpolateRound(previousCountriesValue, d);
				return function(t) {
					node.textContent = i(t);
				};
			});

		let topPanelCountriesText = mainValueGroup.selectAll("." + classPrefix + "topPanelCountriesText")
			.data([numberofCountries]);

		topPanelCountriesText = topPanelCountriesText.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelCountriesText")
			.attr("text-anchor", "start")
			.attr("y", topPanel.height / 2)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[2] + topPanel.mainValueHorPadding)
			.merge(topPanelCountriesText)
			.text(d => d > 1 ? "Countries" : "Country");

		let topPanelRegionalsValue = mainValueGroup.selectAll("." + classPrefix + "topPanelRegionalsValue")
			.data([numberofRegionals]);

		topPanelRegionalsValue = topPanelRegionalsValue.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelRegionalsValue contributionColorFill")
			.attr("text-anchor", "end")
			.merge(topPanelRegionalsValue)
			.attr("y", topPanel.height / 2)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[3] - topPanel.mainValueHorPadding);

		topPanelRegionalsValue.transition()
			.duration(duration)
			.tween("text", function(d) {
				const node = this;
				const i = d3.interpolateRound(previousRegionalsValue, d);
				return function(t) {
					node.textContent = i(t);
				};
			});

		let topPanelRegionalsText = mainValueGroup.selectAll("." + classPrefix + "topPanelRegionalsText")
			.data([numberofRegionals]);

		topPanelRegionalsText = topPanelRegionalsText.enter()
			.append("text")
			.attr("class", classPrefix + "topPanelRegionalsText")
			.attr("text-anchor", "start")
			.attr("y", topPanel.height / 2)
			.attr("x", topPanel.moneyBagPadding + topPanel.leftPadding[3] + topPanel.mainValueHorPadding)
			.merge(topPanelRegionalsText)
			.text(d => d > 1 ? "Regionals" : "Regional");

		let overRectangle = topPanel.main.selectAll("." + classPrefix + "topPanelOverRectangle")
			.data([true]);

		overRectangle = overRectangle.enter()
			.append("rect")
			.attr("class", classPrefix + "topPanelOverRectangle")
			.attr("width", topPanel.width)
			.attr("height", topPanel.height)
			.style("pointer-events", "all")
			.style("opacity", 0)
			.merge(overRectangle);

		overRectangle.on("mouseover", function() {

				currentHoveredElement = this;

				const mouseContainer = d3.mouse(containerDiv.node());

				const mouse = d3.mouse(this);

				tooltip.style("display", "block")
					.html(null);

				const tooltipContainer = tooltip.append("div")
					.style("margin", "0px")
					.style("display", "flex")
					.style("flex-wrap", "wrap")
					.style("width", "280px");

				const tooltipData = [{
					title: "Total:",
					property: mainValue
				}, {
					title: "Rapid Response:",
					property: rapidResponseValue
				}, {
					title: "Underfunded:",
					property: underfundedValue
				}];

				tooltipData.forEach(function(e, i) {
					tooltipContainer.append("div")
						.style("display", "flex")
						.style("flex", "0 56%")
						.html(e.title);

					tooltipContainer.append("div")
						.style("display", "flex")
						.style("flex", "0 44%")
						.style("justify-content", "flex-end")
						.html("$" + formatMoney0Decimals(e.property).replace("G", "B"));
				});

				const tooltipSize = tooltip.node().getBoundingClientRect();

				localVariable.set(this, tooltipSize);

				thisOffset = this.getBoundingClientRect().top - containerDiv.node().getBoundingClientRect().top - (tooltipSize.height - this.getBoundingClientRect().height) / 2;

				tooltip.style("top", thisOffset + "px")
					.style("left", mouse[0] < topPanel.width - 14 - tooltipSize.width ?
						mouseContainer[0] + 14 + "px" :
						mouseContainer[0] - (mouse[0] - (topPanel.width - tooltipSize.width)) + "px");
			})
			.on("mousemove", function() {

				const mouseContainer = d3.mouse(containerDiv.node());

				const mouse = d3.mouse(this);

				const tooltipSize = localVariable.get(this);

				tooltip.style("top", thisOffset + "px")
					.style("left", mouse[0] < topPanel.width - 14 - tooltipSize.width ?
						mouseContainer[0] + 14 + "px" :
						mouseContainer[0] - (mouse[0] - (topPanel.width - tooltipSize.width)) + "px");
			})
			.on("mouseout", function() {
				if (isSnapshotTooltipVisible) return;
				currentHoveredElement = null;
				tooltip.style("display", "none");
			});

		//end of createTopPanel
	};

	function createButtonsPanel(rawData) {

		const clipPath = buttonsPanel.main.append("clipPath")
			.attr("id", classPrefix + "clip")
			.append("rect")
			.attr("width", buttonsNumber * buttonsPanel.buttonWidth)
			.attr("height", buttonsPanel.height);

		const clipPathGroup = buttonsPanel.main.append("g")
			.attr("class", classPrefix + "ClipPathGroup")
			.attr("transform", "translate(" + (buttonsPanel.padding[3]) + ",0)")
			.attr("clip-path", "url(#" + classPrefix + "clip)");

		const buttonsGroup = clipPathGroup.append("g")
			.attr("class", classPrefix + "buttonsGroup")
			.attr("transform", "translate(0,0)")
			.style("cursor", "pointer");

		const buttonsRects = buttonsGroup.selectAll(null)
			.data(yearsArray)
			.enter()
			.append("rect")
			.attr("rx", "2px")
			.attr("ry", "2px")
			.attr("class", classPrefix + "buttonsRects")
			.attr("width", buttonsPanel.buttonWidth - buttonsPanel.buttonsMargin)
			.attr("height", buttonsPanel.height - buttonsPanel.buttonVerticalPadding * 2)
			.attr("y", buttonsPanel.buttonVerticalPadding)
			.attr("x", function(_, i) {
				return i * buttonsPanel.buttonWidth + buttonsPanel.buttonsMargin / 2;
			})
			.style("fill", function(d) {
				return chartState.selectedYear.indexOf(d) > -1 ? unBlue : "#eaeaea";
			});

		const buttonsText = buttonsGroup.selectAll(null)
			.data(yearsArray)
			.enter()
			.append("text")
			.attr("text-anchor", "middle")
			.attr("class", classPrefix + "buttonsText")
			.attr("y", buttonsPanel.height / 1.6)
			.attr("x", function(_, i) {
				return i * buttonsPanel.buttonWidth + buttonsPanel.buttonWidth / 2;
			})
			.style("fill", function(d) {
				return chartState.selectedYear.indexOf(d) > -1 ? "white" : "#444";
			})
			.text(function(d) {
				return d;
			});

		const buttonsCerfGroup = buttonsPanel.main.selectAll(null)
			.data(Object.entries(cerfAllocationTypes).map(e => ({
				value: e[0],
				name: e[1]
			})))
			.enter()
			.append("g")
			.attr("class", classPrefix + "buttonsCerfGroup")
			.attr("transform", "translate(" + (buttonsPanel.cerfButtonsMargin) + ",0)")
			.style("cursor", "pointer");

		const buttonsCerfRects = buttonsCerfGroup.append("rect")
			.attr("rx", "2px")
			.attr("ry", "2px")
			.attr("class", classPrefix + "buttonsCerfRects")
			.attr("height", buttonsPanel.height - buttonsPanel.buttonVerticalPadding * 2)
			.attr("y", buttonsPanel.buttonVerticalPadding)
			.style("fill", function(d) {
				return d.value === chartState.selectedCerfAllocation ? unBlue : "#eaeaea";
			});

		const buttonsCerfText = buttonsCerfGroup.append("text")
			.attr("class", classPrefix + "buttonsCerfText")
			.attr("font-family", "Arial")
			.attr("font-size", 12)
			.attr("y", buttonsPanel.height / 1.6)
			.attr("x", buttonsPanel.buttonsPadding)
			.style("fill", function(d) {
				return d.value === chartState.selectedCerfAllocation ? "white" : "#444";
			})
			.text(function(d) {
				return d.name;
			})
			.each(function() {
				localVariable.set(this.parentNode, this.getComputedTextLength())
			});

		buttonsCerfRects.each(function() {
			d3.select(this)
				.attr("width", localVariable.get(this.parentNode) + 2 * buttonsPanel.buttonsPadding);
		});

		buttonsCerfGroup.each(function(_, i) {
			d3.select(this).attr("transform", "translate(" + (i ? localVariable.get(this.previousSibling) : buttonsPanel.cerfButtonsMargin) + ",0)")
			localVariable.set(this, this.getBBox().width + buttonsPanel.buttonsMargin + (i ? localVariable.get(this.previousSibling) : buttonsPanel.cerfButtonsMargin));
		});

		const leftArrow = buttonsPanel.main.append("g")
			.attr("class", classPrefix + "LeftArrowGroup")
			.style("cursor", "pointer")
			.style("opacity", 0)
			.attr("pointer-events", "none")
			.attr("transform", "translate(" + buttonsPanel.padding[3] + ",0)");

		const leftArrowRect = leftArrow.append("rect")
			.style("fill", "white")
			.attr("width", buttonsPanel.arrowPadding)
			.attr("height", buttonsPanel.height - buttonsPanel.padding[0] - buttonsPanel.buttonVerticalPadding * 2)
			.attr("y", buttonsPanel.buttonVerticalPadding);

		const leftArrowText = leftArrow.append("text")
			.attr("class", classPrefix + "leftArrowText")
			.attr("x", 0)
			.attr("y", buttonsPanel.height - buttonsPanel.buttonVerticalPadding * 2.1)
			.style("fill", "#666")
			.text("\u25c4");

		const rightArrow = buttonsPanel.main.append("g")
			.attr("class", classPrefix + "RightArrowGroup")
			.style("cursor", "pointer")
			.style("opacity", 0)
			.attr("pointer-events", "none")
			.attr("transform", "translate(" + (buttonsPanel.padding[3] + buttonsPanel.arrowPadding +
				(buttonsNumber * buttonsPanel.buttonWidth)) + ",0)");

		const rightArrowRect = rightArrow.append("rect")
			.style("fill", "white")
			.attr("width", buttonsPanel.arrowPadding)
			.attr("height", buttonsPanel.height - buttonsPanel.padding[0] - buttonsPanel.buttonVerticalPadding * 2)
			.attr("y", buttonsPanel.buttonVerticalPadding);

		const rightArrowText = rightArrow.append("text")
			.attr("class", classPrefix + "rightArrowText")
			.attr("x", -1)
			.attr("y", buttonsPanel.height - buttonsPanel.buttonVerticalPadding * 2.1)
			.style("fill", "#666")
			.text("\u25ba");

		if (yearsArray.length > buttonsNumber) {

			clipPathGroup.attr("transform", "translate(" + (buttonsPanel.padding[3] + buttonsPanel.arrowPadding) + ",0)")

			rightArrow.style("opacity", 1)
				.attr("pointer-events", "all");

			leftArrow.style("opacity", 1)
				.attr("pointer-events", "all");

			repositionButtonsGroup();

			checkCurrentTranslate();

			leftArrow.on("click", function() {
				leftArrow.attr("pointer-events", "none");
				const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];
				rightArrow.select("text").style("fill", "#666");
				rightArrow.attr("pointer-events", "all");
				buttonsGroup.transition()
					.duration(duration)
					.attr("transform", "translate(" +
						Math.min(0, (currentTranslate + buttonsNumber * buttonsPanel.buttonWidth)) + ",0)")
					.on("end", checkArrows);
			});

			rightArrow.on("click", function() {
				rightArrow.attr("pointer-events", "none");
				const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];
				leftArrow.select("text").style("fill", "#666");
				leftArrow.attr("pointer-events", "all");
				buttonsGroup.transition()
					.duration(duration)
					.attr("transform", "translate(" +
						Math.max(-((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth),
							(-(Math.abs(currentTranslate) + buttonsNumber * buttonsPanel.buttonWidth))) +
						",0)")
					.on("end", checkArrows);
			});
		};

		buttonsRects.on("mouseover", mouseOverButtonsRects)
			.on("mouseout", mouseOutButtonsRects)
			.on("click", function(d) {
				const self = this;
				if (d3.event.altKey) {
					clickButtonsRects(d, false);
					return;
				};
				if (localVariable.get(this) !== "clicked") {
					localVariable.set(this, "clicked");
					setTimeout(function() {
						if (localVariable.get(self) === "clicked") {
							clickButtonsRects(d, true);
						};
						localVariable.set(self, null);
					}, 250);
				} else {
					clickButtonsRects(d, false);
					localVariable.set(this, null);
				};
			});

		d3.select("body").on("d3ChartsYear." + classPrefix, function() {
			clickButtonsRects(validateCustomEventYear(+d3.event.detail), true);
			repositionButtonsGroup();
			checkArrows();
		});

		function checkArrows() {

			const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];

			if (currentTranslate === 0) {
				leftArrow.select("text").style("fill", "#ccc");
				leftArrow.attr("pointer-events", "none");
			} else {
				leftArrow.select("text").style("fill", "#666");
				leftArrow.attr("pointer-events", "all");
			};

			if (Math.abs(currentTranslate) >= ((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth)) {
				rightArrow.select("text").style("fill", "#ccc");
				rightArrow.attr("pointer-events", "none");
			} else {
				rightArrow.select("text").style("fill", "#666");
				rightArrow.attr("pointer-events", "all");
			}

		};

		function checkCurrentTranslate() {

			const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];

			if (currentTranslate === 0) {
				leftArrow.select("text").style("fill", "#ccc")
				leftArrow.attr("pointer-events", "none");
			};

			if (Math.abs(currentTranslate) >= ((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth)) {
				rightArrow.select("text").style("fill", "#ccc")
				rightArrow.attr("pointer-events", "none");
			};

		};

		function repositionButtonsGroup() {

			const firstYearIndex = chartState.selectedYear[0] < yearsArray[buttonsNumber / 2] ?
				0 :
				chartState.selectedYear[0] > yearsArray[yearsArray.length - (buttonsNumber / 2)] ?
				yearsArray.length - buttonsNumber :
				yearsArray.indexOf(chartState.selectedYear[0]) - (buttonsNumber / 2);

			buttonsGroup.attr("transform", "translate(" +
				(-(buttonsPanel.buttonWidth * firstYearIndex)) +
				",0)");

		};

		function mouseOverButtonsRects(d) {
			tooltip.style("display", "block")
				.html(null)

			const innerTooltip = tooltip.append("div")
				.style("max-width", "200px")
				.attr("id", classPrefix + "InnerTooltipDiv");

			innerTooltip.html("Click for selecting a single year. Double-click or ALT + click for selecting multiple years.");

			const containerSize = containerDiv.node().getBoundingClientRect();

			const thisSize = this.getBoundingClientRect();

			tooltipSize = tooltip.node().getBoundingClientRect();

			tooltip.style("left", (thisSize.left + thisSize.width / 2 - containerSize.left) > containerSize.width - (tooltipSize.width / 2) - padding[1] ?
					containerSize.width - tooltipSize.width - padding[1] + "px" : (thisSize.left + thisSize.width / 2 - containerSize.left) < tooltipSize.width / 2 + buttonsPanel.padding[3] + padding[0] ?
					buttonsPanel.padding[3] + padding[0] + "px" : (thisSize.left + thisSize.width / 2 - containerSize.left) - (tooltipSize.width / 2) + "px")
				.style("top", (thisSize.top + thisSize.height / 2 - containerSize.top) < tooltipSize.height ? thisSize.top - containerSize.top + thisSize.height + 2 + "px" :
					thisSize.top - containerSize.top - tooltipSize.height - 4 + "px");

			d3.select(this).style("fill", unBlue);
			buttonsText.filter(function(e) {
					return e === d
				})
				.style("fill", "white");
		};

		function mouseOutButtonsRects(d) {
			tooltip.style("display", "none");
			if (chartState.selectedYear.indexOf(d) > -1) return;
			d3.select(this).style("fill", "#eaeaea");
			buttonsText.filter(function(e) {
					return e === d
				})
				.style("fill", "#444");
		};

		function clickButtonsRects(d, singleSelection) {

			if (singleSelection) {
				chartState.selectedYear = [d];
			} else {
				const index = chartState.selectedYear.indexOf(d);
				if (index > -1) {
					if (chartState.selectedYear.length === 1) {
						return;
					} else {
						chartState.selectedYear.splice(index, 1);
					}
				} else {
					chartState.selectedYear.push(d);
				};
			};

			const allYears = chartState.selectedYear.map(function(d) {
				return d;
			}).join("|");

			if (queryStringValues.has("year")) {
				queryStringValues.set("year", allYears);
			} else {
				queryStringValues.append("year", allYears);
			};

			buttonsRects.style("fill", function(e) {
				return chartState.selectedYear.indexOf(e) > -1 ? unBlue : "#eaeaea";
			});

			buttonsText.style("fill", function(e) {
				return chartState.selectedYear.indexOf(e) > -1 ? "white" : "#444";
			});

			const data = processData(rawData);

			verifyCentroids(data.map);

			createTopPanel(data);

			createChoropleth(data);

			createLegend(data);

			setYearsDescriptionDiv(data);

			createStackedBar(data);

			//end of clickButtonsRects
		};

		buttonsCerfRects.on("mouseover", mouseOverButtonsCerfRects)
			.on("mouseout", mouseOutButtonsCerfRects);

		function mouseOverButtonsCerfRects(d) {
			d3.select(this).style("fill", unBlue);
			buttonsCerfText.filter(function(e) {
					return e.value === d.value
				})
				.style("fill", "white");
		};

		function mouseOutButtonsCerfRects(d) {
			if (d.value === chartState.selectedCerfAllocation) return;
			d3.select(this).style("fill", "#eaeaea");
			buttonsCerfText.filter(function(e) {
					return e.value === d.value
				})
				.style("fill", "#444");
		};


		buttonsCerfRects.on("click", function(d) {

			chartState.selectedCerfAllocation = d.value;

			if (queryStringValues.has("cerfallocation")) {
				queryStringValues.set("cerfallocation", d);
			} else {
				queryStringValues.append("cerfallocation", d);
			};

			buttonsPanel.main.selectAll("." + classPrefix + "buttonsCerfRects")
				.style("fill", function(e) {
					return e.value === chartState.selectedCerfAllocation ? unBlue : "#eaeaea";
				});

			buttonsPanel.main.selectAll("." + classPrefix + "buttonsCerfText")
				.style("fill", function(e) {
					return e.value === chartState.selectedCerfAllocation ? "white" : "#444";
				});

			const data = processData(rawData);

			createTopPanel(data);

			createChoropleth(data);

			createLegend(data);

			createStackedBar(data);

		});

		//end of createButtonsPanel
	};

	function createChoropleth(unfilteredData) {

		const data = unfilteredData.map.filter(function(d) {
			return d[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`];
		});

		zoom.on("zoom", zoomed);

		if (data.length) {
			zoomToBoundingBox(data);
		} else {
			zoom.transform(mapPanel.main.transition().duration(duration), d3.zoomIdentity)
		};

		const allValues = data.map(function(d) {
			return d[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`];
		}).sort(function(a, b) {
			return a - b
		});

		const thisInterpolator = chartState.selectedCerfAllocation === "0" ? colorInterpolatorTotal :
			chartState.selectedCerfAllocation === "3" ? colorInterpolatorRR : colorInterpolatorUnderfunded;

		const newColors = d3.range(0.1, 1.1, 0.1).map(function(d) {
			return thisInterpolator(d);
		});

		colorScale.domain(allValues)
			.range(newColors);

		const countries = mapContainer.selectAll("." + classPrefix + "MapPath")
			.data(data, function(d) {
				return d.properties ? d.properties.ISO_2 : d.isoCode;
			});

		const countriesExit = countries.exit()
			.attr("pointer-events", "none")
			.transition()
			.duration(duration)
			.style("fill", countriesBackground);

		countries.attr("pointer-events", "all")
			.transition()
			.duration(duration)
			.style("fill", function(d) {
				return colorScale(d[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`]);
			});

		let countryNames = mapContainer.selectAll("." + classPrefix + "countryNames")
			.data(data.filter(function(e) {
				return centroids[e.isoCode] && !hardcodedRegionals.includes(e.id);
			}), function(d) {
				return d.isoCode
			});

		const countryNamesExit = countryNames.exit().remove();

		const countryNamesEnter = countryNames.enter()
			.append("text")
			.attr("class", classPrefix + "countryNames")
			.attr("x", function(d) {
				return centroids[d.isoCode].x;
			})
			.attr("y", function(d) {
				return centroids[d.isoCode].y;
			})
			.text(function(d) {
				return d.countryAbbreviation;
			})
			.call(wrapText2, countryNameMaxLength);

		countryNames = countryNamesEnter.merge(countryNames);

		if (!chartState.showNames) {
			countryNames.each((_, i, n) => d3.select(n[i]).style("display", null)).call(displayLabels);
		};

		const globalCountry = mapContainer.selectAll("." + classPrefix + "MapPath")
			.filter(d => d.properties ? d.properties.ISO_2 === globalIsoCode : d.isoCode === globalIsoCode);

		const globalDatum = data.find(e => e.isoCode === globalIsoCode);

		if (globalDatum && globalDatum[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`]) {
			globalCountry.style("opacity", 1);
			mapContainer.select("." + classPrefix + "CerfText").style("opacity", 1);
		} else {
			globalCountry.style("opacity", 0);
			mapContainer.select("." + classPrefix + "CerfText").style("opacity", 0);
		};

		countries.on("mouseover", mouseover)
			.on("mouseout", function() {
				if (isSnapshotTooltipVisible) return;
				currentHoveredElement = null;
				tooltip.html(null)
					.style("display", "none");
			});

		function mouseover(d) {

			currentHoveredElement = this;

			tooltip.style("display", "block")
				.html(null);

			const innerTooltipDiv = tooltip.append("div")
				.style("max-width", innerTooltipDivWidth + "px")
				.attr("id", classPrefix + "innerTooltipDiv");

			innerTooltipDiv.append("div")
				.style("margin-bottom", "12px")
				.append("strong")
				.style("font-size", "16px")
				.html(d.country);

			const tooltipContainer = innerTooltipDiv.append("div")
				.style("display", "flex")
				.style("margin-bottom", "8px")
				.style("width", "100%");

			tooltipContainer.append("div")
				.style("display", "flex")
				.style("flex", "0 60%")
				.html(cerfAllocationTypes[chartState.selectedCerfAllocation]);

			tooltipContainer.append("div")
				.style("display", "flex")
				.style("flex", "0 40%")
				.style("justify-content", "flex-end")
				.html("$" + formatMoney0Decimals(d[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`]).replace("G", "B"));

			innerTooltipDiv.append("div")
				.style("margin-bottom", "2px")
				.style("font-size", "12px")
				.style("color", "#444")
				.html("Allocations by sector");

			const svgData = Object.keys(clustersList).map(e => ({
					cluster: clustersList[e],
					clusterId: e,
					value: d[`cerf${separator}${chartState.selectedCerfAllocation}${separator}${e}`]
				})).filter(e => e.value)
				.sort((a, b) => b.value - a.value);

			const tooltipSvgPadding = [16, 28, 4, 86],
				tooltipSvgHeight = tooltipSvgPadding[0] + tooltipSvgPadding[2] + maxColumnRectHeight * 1.8 * svgData.length;

			const tooltipSvg = innerTooltipDiv.append("svg")
				.attr("width", innerTooltipDivWidth)
				.attr("height", tooltipSvgHeight);

			const yScale = d3.scaleBand()
				.domain(svgData.map(e => e.cluster))
				.range([tooltipSvgPadding[0], tooltipSvgHeight - tooltipSvgPadding[2]])
				.paddingInner(0.5)
				.paddingOuter(0.5);

			const xScale = d3.scaleLinear()
				.range([tooltipSvgPadding[3], innerTooltipDivWidth - tooltipSvgPadding[1]])
				.domain([0, d3.max(svgData, e => e.value)]);

			const xAxis = d3.axisTop(xScale)
				.tickSizeOuter(0)
				.tickSizeInner(-(tooltipSvgHeight - tooltipSvgPadding[0] - tooltipSvgPadding[2]))
				.ticks(3)
				.tickFormat(d => "$" + formatSIaxes(d).replace("G", "B"));

			const yAxis = d3.axisLeft(yScale)
				.tickPadding(clusterIconSize + 2 * clusterIconPadding)
				.tickSize(3);

			tooltipSvg.append("g")
				.attr("class", classPrefix + "xAxisGroupColumnBySector")
				.attr("transform", "translate(0," + tooltipSvgPadding[0] + ")")
				.call(xAxis)
				.selectAll(".tick")
				.filter(d => d === 0)
				.remove();

			tooltipSvg.append("g")
				.attr("class", classPrefix + "yAxisGroupColumnBySector")
				.attr("transform", "translate(" + tooltipSvgPadding[3] + ",0)")
				.call(customAxis);

			function customAxis(group) {
				const sel = group.selection ? group.selection() : group;
				group.call(yAxis);
				sel.selectAll(".tick text")
					.filter(d => d.indexOf(" ") > -1)
					.text(d => clusterNamesScale(d).split(" ")[0])
					.attr("x", -(yAxis.tickPadding() + yAxis.tickSize()))
					.attr("dy", d => clusterNamesScale(d).indexOf(" ") > -1 ? "-0.3em" : "0.32em")
					.append("tspan")
					.attr("dy", "1.1em")
					.attr("x", -(yAxis.tickPadding() + yAxis.tickSize()))
					.text(d => clusterNamesScale(d).split(" ")[1]);
				if (sel !== group) group.selectAll(".tick text")
					.filter(d => d.indexOf(" ") > -1)
					.attrTween("x", null)
					.tween("text", null);
			};

			tooltipSvg.selectAll(null)
				.data(svgData)
				.enter()
				.append("rect")
				.attr("stroke", "#aaa")
				.attr("stroke-width", 0.5)
				.attr("height", yScale.bandwidth())
				.attr("width", 0)
				.style("fill", chartState.selectedCerfAllocation === "0" ? choroplethColorTotal : chartState.selectedCerfAllocation === "3" ? choroplethColorRR : choroplethColorUnderfunded)
				.attr("x", xScale(0))
				.attr("y", d => yScale(d.cluster))
				.transition()
				.duration(duration)
				.attr("width", d => xScale(d.value) - tooltipSvgPadding[3]);

			tooltipSvg.selectAll(null)
				.data(svgData)
				.enter()
				.append("text")
				.attr("class", classPrefix + "labelsColumnBySector")
				.attr("x", tooltipSvgPadding[3] + labelsColumnPadding)
				.attr("y", d => yScale(d.cluster) + yScale.bandwidth() / 2)
				.transition()
				.duration(duration)
				.attr("x", d => xScale(d.value) + labelsColumnPadding)
				.textTween((d, i, n) => {
					const interpolator = d3.interpolate(reverseFormat(n[i].textContent) || 0, d.value);
					return t => d.value ? formatSIFloat(interpolator(t)).replace("G", "B") : 0;
				});

			tooltipSvg.selectAll(null)
				.data(svgData)
				.enter()
				.append("image")
				.attr("x", tooltipSvgPadding[3] - clusterIconPadding - clusterIconSize - yAxis.tickSize())
				.attr("y", d => yScale(d.cluster) - (clusterIconSize - yScale.bandwidth()) / 2)
				.attr("width", clusterIconSize)
				.attr("height", clusterIconSize)
				.attr("href", d => clustersIconsData[d.clusterId]);

			const thisBox = this.getBoundingClientRect();

			const containerBox = containerDiv.node().getBoundingClientRect();

			const tooltipBox = tooltip.node().getBoundingClientRect();

			const thisOffsetTop = (thisBox.bottom + thisBox.top) / 2 - containerBox.top - (tooltipBox.height / 2);

			const thisOffsetLeft = containerBox.right - thisBox.right > tooltipBox.width + (2 * tooltipMargin) ?
				thisBox.right - containerBox.left + tooltipMargin :
				thisBox.left - containerBox.left - tooltipBox.width - tooltipMargin;

			tooltip.style("top", thisOffsetTop + "px")
				.style("left", thisOffsetLeft + "px");
		};

		function zoomed() {

			mapContainer.attr("transform", d3.event.transform);

			mapContainer.selectAll("circle." + classPrefix + "MapPath, ." + classPrefix + "Border")
				.style("stroke-width", 1 / d3.event.transform.k + "px");

			mapContainer.select("." + classPrefix + "CerfText")
				.style("font-size", 10 / d3.event.transform.k + "px")
				.attr("y", function() {
					const globalCerf = hardcodedAllocations.find(function(e) {
						return e.isoCode === globalIsoCode;
					});
					return mapProjection([globalCerf.long, globalCerf.lat])[1] + cerfCircleRadius + 8 / d3.event.transform.k;
				});

			const allLabels = mapContainer.selectAll("." + classPrefix + "countryNames");

			allLabels.style("font-size", 10 / d3.event.transform.k + "px")

			if (!chartState.showNames) {
				allLabels.each((_, i, n) => d3.select(n[i]).style("display", null)).call(displayLabels);
			};

			//end of zoomed
		};

		mapZoomButtonPanel.main.select("." + classPrefix + "zoomInGroup")
			.on("click", function() {
				zoom.scaleBy(mapPanel.main.transition().duration(duration), 2);
			});

		mapZoomButtonPanel.main.select("." + classPrefix + "zoomOutGroup")
			.on("click", function() {
				zoom.scaleBy(mapPanel.main.transition().duration(duration), 0.5);
			});

		function zoomToBoundingBox(data) {

			//Change this: use the bounding box of the geometry instead of a centroid

			const boundingBox = data.reduce((acc, curr) => {
				if (centroids[curr.isoCode]) {
					acc.n = Math.min(acc.n, centroids[curr.isoCode].y - zoomBoundingMarginVert);
					acc.s = Math.max(acc.s, centroids[curr.isoCode].y + zoomBoundingMarginVert);
					acc.e = Math.max(acc.e, centroids[curr.isoCode].x + zoomBoundingMarginHor);
					acc.w = Math.min(acc.w, centroids[curr.isoCode].x - zoomBoundingMarginHor);
				};
				return acc;
			}, {
				n: Infinity,
				s: -Infinity,
				e: -Infinity,
				w: Infinity
			});

			const midPointX = (boundingBox.w + boundingBox.e) / 2;
			const midPointY = (boundingBox.n + boundingBox.s) / 2;
			const scale = Math.min(mapPanel.width / (boundingBox.e - boundingBox.w), mapPanel.height / (boundingBox.s - boundingBox.n));
			const translate = [mapPanel.width / 2 - scale * midPointX, mapPanel.height / 2 - scale * midPointY];

			zoom.transform(mapPanel.main.transition().duration(duration),
				d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));

		};

		//end of createChoropleth
	};

	function createLegend(data) {

		const legendTitle = legendPanel.main.selectAll("." + classPrefix + "legendTitle")
			.data([true])
			.enter()
			.append("text")
			.attr("class", classPrefix + "legendTitle")
			.attr("x", legendPanel.padding[3])
			.attr("y", legendPanel.padding[0] - 10)
			.text("Legend");

		let legendRects = legendPanel.main.selectAll("." + classPrefix + "LegendRects")
			.data([colorScale.domain()[0]].concat(colorScale.quantiles()));

		legendRects = legendRects.enter()
			.append("rect")
			.attr("class", classPrefix + "LegendRects")
			.attr("y", legendPanel.padding[0])
			.attr("x", function(_, i) {
				return legendPanel.padding[3] + i * 11
			})
			.style("stroke", "#444")
			.attr("width", 9)
			.attr("height", 11)
			.merge(legendRects)
			.style("fill", function(d) {
				return colorScale(d);
			});

		const legendColorLines = legendPanel.main.selectAll("." + classPrefix + "LegendColorLines")
			.data(d3.range(2))
			.enter()
			.append("line")
			.attr("class", classPrefix + "LegendColorLines")
			.attr("y1", legendPanel.padding[0] + 10)
			.attr("y2", legendPanel.padding[0] + 20)
			.attr("x1", function(d) {
				return d ? legendPanel.padding[3] + 108 : legendPanel.padding[3];
			})
			.attr("x2", function(d) {
				return d ? legendPanel.padding[3] + 108 : legendPanel.padding[3];
			})
			.style("stroke-width", "1px")
			.style("shape-rendering", "crispEdges")
			.style("stroke", "#444");

		let legendColorTexts = legendPanel.main.selectAll("." + classPrefix + "LegendColorTexts")
			.data(d3.extent(colorScale.domain()));

		legendColorTexts = legendColorTexts.enter()
			.append("text")
			.attr("class", classPrefix + "LegendColorTexts")
			.attr("y", 42)
			.attr("x", function(_, i) {
				return i ? legendPanel.padding[3] + 108 : legendPanel.padding[3];
			})
			.attr("text-anchor", function(_, i) {
				return i ? "end" : "start";
			})
			.merge(legendColorTexts);

		legendColorTexts.transition()
			.duration(duration)
			.textTween(function(d) {
				const i = d3.interpolate(reverseFormat(this.textContent) || 0, d);
				return function(t) {
					return d3.formatPrefix(".0", i(t))(i(t)).replace("G", "B");
				};
			});

		//end of createLegend
	};

	function createStackedBar(unfilteredData) {

		const data = unfilteredData.bar.filter(function(d) {
			return d[`cerf${separator}${chartState.selectedCerfAllocation}`];
		});

		const legendGroup = stackedSvg.selectAll("." + classPrefix + "legendGroup")
			.data([true])
			.enter()
			.append("g")
			.attr("class", classPrefix + "legendGroup")
			.attr("transform", "translate(" + stackedPadding[3] + "," + (stackedSvgHeight - legendGroupPadding) + ")");

		const legend = legendGroup.selectAll(null)
			.data(cerfTypeKeys)
			.enter()
			.append("g")
			.attr("transform", (_, i) => "translate(" + (i * 120) + ",0)");

		legend.append("rect")
			.attr("width", legendGroupRectSize)
			.attr("height", legendGroupRectSize)
			.attr("fill", d => d === "3" ? choroplethColorRR : choroplethColorUnderfunded);

		legend.append("text")
			.attr("x", legendGroupRectSize + 4)
			.attr("y", legendGroupRectSize / 2)
			.text(d => cerfAllocationTypes[d]);

		data.sort((a, b) => b[`cerf${separator}${chartState.selectedCerfAllocation}`] - a[`cerf${separator}${chartState.selectedCerfAllocation}`]);

		const dynamicWidth = Math.min(stackedSvgWidth - stackedPadding[3] - stackedPadding[1],
			(stackedPadding[1] + stackedPadding[3] + data.length * stackedBarMaxWidth));

		xScaleBar.domain(data.map(d => d.id))
			.range([stackedPadding[3], dynamicWidth - stackedPadding[1]]);

		yScaleBar.domain([0, data[0][`cerf${separator}${chartState.selectedCerfAllocation}`]]);

		xAxisBarGroup.transition()
			.duration(duration)
			.call(customAxisBarChart);

		function customAxisBarChart(group) {
			const sel = group.selection ? group.selection() : group;
			group.call(xAxisBar);
			sel.selectAll(".tick text")
				.text(d => unAgenciesNamesList[d])
				.call(wrapText, xScaleBar.step());
			if (sel !== group) group.selectAll(".tick text")
				.attrTween("x", null)
				.tween("text", null);
		};

		const stackedData = stack(data);

		let barsGroups = stackedSvg.selectAll("." + classPrefix + "barsGroups")
			.data(stackedData, d => d.key);

		const barGroupsExit = barsGroups.exit().remove();

		const barGroupsEnter = barsGroups.enter()
			.append("g")
			.attr("class", classPrefix + "barsGroups")
			.attr("pointer-events", "none")
			.style("fill", d => d.key === `cerf${separator}3` ? choroplethColorRR : choroplethColorUnderfunded);

		barsGroups = barGroupsEnter.merge(barsGroups);

		let bars = barsGroups.selectAll("." + classPrefix + "bars")
			.data(d => d, d => d.data.id);

		const barsExit = bars.exit()
			.transition()
			.duration(duration)
			.attr("height", 0)
			.attr("y", stackedSvgHeight - stackedPadding[2])
			.style("opacity", 0)
			.remove();

		const barsEnter = bars.enter()
			.append("rect")
			.attr("class", classPrefix + "bars")
			.attr("stroke", "#aaa")
			.attr("stroke-width", 0.5)
			.attr("width", xScaleBar.bandwidth())
			.attr("height", 0)
			.attr("y", yScaleBar(0))
			.attr("x", d => xScaleBar(d.data.id))

		bars = barsEnter.merge(bars);

		bars.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("width", xScaleBar.bandwidth())
			.attr("x", d => xScaleBar(d.data.id))
			.attr("y", d => d[0] === d[1] ? yScaleBar(0) : yScaleBar(d[1]))
			.attr("height", d => yScaleBar(d[0]) - yScaleBar(d[1]));

		let underfundedLabel = stackedSvg.selectAll("." + classPrefix + "underfundedLabel")
			.data(data.filter(d => d[`cerf${separator}4`]), d => d.id);

		const underfundedLabelExit = underfundedLabel.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const underfundedLabelEnter = underfundedLabel.enter()
			.append("text")
			.attr("class", classPrefix + "underfundedLabel")
			.style("opacity", 0)
			.style("fill", d3.color(choroplethColorUnderfunded).darker(0.4))
			.attr("x", d => xScaleBar(d.id) + xScaleBar.bandwidth() / 2)
			.attr("y", stackedSvgHeight - stackedPadding[2]);

		underfundedLabel = underfundedLabelEnter.merge(underfundedLabel);

		underfundedLabel.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => xScaleBar(d.id) + xScaleBar.bandwidth() / 2)
			.attr("y", d => yScaleBar(d[`cerf${separator}3`] + d[`cerf${separator}4`]) - (d[`cerf${separator}3`] ? barLabelPadding : barLabelPaddingBase))
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent) || 0, d[`cerf${separator}4`]);
				return t => d3.formatPrefix(".0", interpolator(t))(interpolator(t)).replace("G", "B") + (d[`cerf${separator}3`] ? "/" : "");
			});

		let rapidResponseLabel = stackedSvg.selectAll("." + classPrefix + "rapidResponseLabel")
			.data(data.filter(d => d[`cerf${separator}3`]), d => d.id);

		const rapidResponseLabelExit = rapidResponseLabel.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const rapidResponseLabelEnter = rapidResponseLabel.enter()
			.append("text")
			.attr("class", classPrefix + "rapidResponseLabel")
			.style("opacity", 0)
			.style("fill", d3.color(choroplethColorRR).darker(0.5))
			.attr("x", d => xScaleBar(d.id) + xScaleBar.bandwidth() / 2)
			.attr("y", stackedSvgHeight - stackedPadding[2]);

		rapidResponseLabel = rapidResponseLabelEnter.merge(rapidResponseLabel);

		rapidResponseLabel.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => xScaleBar(d.id) + xScaleBar.bandwidth() / 2)
			.attr("y", d => yScaleBar(d[`cerf${separator}3`] + d[`cerf${separator}4`]) - barLabelPaddingBase)
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent) || 0, d[`cerf${separator}3`]);
				return t => d3.formatPrefix(".0", interpolator(t))(interpolator(t)).replace("G", "B");
			});

		let barsTooltipRectangles = stackedSvg.selectAll("." + classPrefix + "barsTooltipRectangles")
			.data(data, d => d.id);

		const barsTooltipRectanglesExit = barsTooltipRectangles.exit().remove();

		const barsTooltipRectanglesEnter = barsTooltipRectangles.enter()
			.append("rect")
			.attr("class", classPrefix + "barsTooltipRectangles")
			.attr("pointer-events", "all")
			.style("opacity", 0)
			.attr("y", stackedPadding[0])
			.attr("height", stackedSvgHeight - stackedPadding[0] - stackedPadding[2])
			.attr("width", xScaleBar.step())
			.attr("x", d => xScaleBar(d.id) - (xScaleBar.step() - xScaleBar.bandwidth()) / 2);

		barsTooltipRectangles = barsTooltipRectanglesEnter.merge(barsTooltipRectangles);

		barsTooltipRectangles.transition()
			.duration(duration)
			.attr("width", xScaleBar.step())
			.attr("x", d => xScaleBar(d.id) - (xScaleBar.step() - xScaleBar.bandwidth()) / 2);

		barsTooltipRectangles.on("mouseover", mouseoverBarsTooltipRectangles)
			.on("mouseout", mouseoutBarsTooltipRectangles);

		function mouseoverBarsTooltipRectangles(d) {

			currentHoveredElement = this;

			tooltipBar.style("display", "block")
				.html(null);

			const innerTooltipDiv = tooltipBar.append("div")
				.style("width", innerTooltipDivWidth + "px")
				.attr("id", classPrefix + "innerTooltipDiv");

			innerTooltipDiv.append("div")
				.style("margin-bottom", "12px")
				.append("strong")
				.style("font-size", "16px")
				.html(unAgenciesNamesList[d.id]);

			const tooltipContainer = innerTooltipDiv.append("div")
				.style("display", "flex")
				.style("flex-wrap", "wrap")
				.style("width", "100%");

			Object.keys(cerfAllocationTypes).forEach(row => {
				const rowDiv = tooltipContainer.append("div")
					.style("width", "100%")
					.style("margin-bottom", "4px")
					.style("display", "flex");

				rowDiv.append("div")
					.style("display", "flex")
					.style("flex", "0 60%")
					.html(cerfAllocationTypes[row]);

				rowDiv.append("div")
					.style("display", "flex")
					.style("flex", "0 40%")
					.style("justify-content", "flex-end")
					.html("$" + formatMoney0Decimals(d[`cerf${separator}${row}`]).replace("G", "B"));
			});

			const thisBox = this.getBoundingClientRect();

			const containerBox = stackedBarchartContainerDiv.node().getBoundingClientRect();

			const tooltipBox = tooltipBar.node().getBoundingClientRect();

			const thisOffsetTop = (containerBox.height / 2) - (tooltipBox.height / 2);

			const thisOffsetLeft = containerBox.right - thisBox.right > tooltipBox.width + tooltipMargin ?
				thisBox.left - containerBox.left + thisBox.width :
				thisBox.left - containerBox.left - tooltipBox.width;

			tooltipBar.style("top", thisOffsetTop + "px")
				.style("left", thisOffsetLeft + "px");

		};

		function mouseoutBarsTooltipRectangles() {
			if (isSnapshotTooltipVisible) return;
			currentHoveredElement = null;
			tooltipBar.style("display", "none")
				.html(null);
		};

		//end of createStackedBar
	};

	function preProcessData(rawData) {

		rawData.forEach(function(row) {
			if (yearsArray.indexOf(+row.AllocationYear) === -1) yearsArray.push(+row.AllocationYear);
		});

		yearsArray.sort(function(a, b) {
			return a - b;
		});

		//end of preProcessData
	};

	function createFundNamesList(fundsData) {
		fundsData.forEach(row => {
			fundNamesList[row.id + ""] = row.PooledFundName;
			fundAbbreviatedNamesList[row.id + ""] = row.PooledFundNameAbbrv;
			fundNamesListKeys.push(row.id + "");
			fundIsoCodesList[row.id + ""] = row.ISO2Code;
			fundIsoCodes3List[row.id + ""] = row.CountryCode;
			fundLatLongList[row.ISO2Code] = [row.latitude, row.longitude];
		});
	};

	function createUnAgenciesNamesList(unAgenciesTypesData) {
		unAgenciesTypesData.forEach(row => {
			unAgenciesNamesList[row.agencyID + ""] = row.agencyName;
			unAgenciesShortNamesList[row.agencyID + ""] = row.agencyShortName;
		});
	};

	function createPartnersList(partnersData) {
		partnersData.forEach(row => {
			partnersList[row.id + ""] = row.OrganizationTypeName;
		});
	};

	function createClustersList(clustersData) {
		clustersData.forEach(row => {
			clustersList[row.id + ""] = row.ClustNm;
		});
	};

	function createAllocationTypesList(allocationTypesData) {
		allocationTypesData.forEach(row => {
			allocationTypesList[row.id + ""] = row.AllocationName;
			if (cerfTypeKeys.includes(row.id + "")) cerfAllocationTypes[row.id + ""] = row.AllocationName;
		});
	};

	function verifyCentroids(data) {
		data.forEach(row => {
			if (!centroids[row.isoCode] || isNaN(centroids[row.isoCode].x) || isNaN(centroids[row.isoCode].y)) {
				if (!isNaN(fundLatLongList[row.isoCode][0]) || !isNaN(fundLatLongList[row.isoCode][1])) {
					centroids[row.isoCode] = {
						x: mapProjection([fundLatLongList[row.isoCode][1], fundLatLongList[row.isoCode][0]])[0],
						y: mapProjection([fundLatLongList[row.isoCode][1], fundLatLongList[row.isoCode][0]])[1]
					};
				} else {
					centroids[row.isoCode] = {
						x: mapProjection([0, 0])[0],
						y: mapProjection([0, 0])[1]
					};
					console.warn("Attention: " + row.isoCode + "(" + row.countryName + ") has no centroid");
				};
			};
		});
	};

	function processData(rawData) {

		const data = {
			map: [],
			bar: [],
			projects: new Set()
		};

		rawData.forEach(function(row) {
			if (chartState.selectedYear.indexOf(+row.AllocationYear) > -1) {

				if (chartState.selectedCerfAllocation === "0" || row.AllocationSurceId.toString() === chartState.selectedCerfAllocation) {
					row.ProjList.toString().split("##").forEach(e => data.projects.add(e));
				};

				const foundCountry = data.map.find(function(d) {
					return d.id === row.PooledFundId;
				});

				if (foundCountry) {
					populateCountryObject(foundCountry, row);
				} else {
					const countryObject = {
						id: row.PooledFundId,
						country: fundNamesList[row.PooledFundId],
						countryAbbreviation: fundAbbreviatedNamesList[row.PooledFundId],
						isoCode: fundIsoCodesList[row.PooledFundId],
						allocations: []
					};
					Object.keys(cerfAllocationTypes).forEach(outerRow => {
						Object.keys(clustersList).forEach(innerRow => {
							countryObject[`cerf${separator}${outerRow}${separator}${innerRow}`] = 0;
						});
						countryObject[`cerf${separator}${outerRow}${separator}0`] = 0;
					});
					populateCountryObject(countryObject, row);
					data.map.push(countryObject);
				};

				const foundAgency = data.bar.find(function(d) {
					return d.id === row.PartnerCode;
				});

				if (foundAgency) {
					populateAgencyObject(foundAgency, row);
				} else {
					const agencyObject = {
						id: row.PartnerCode,
						agency: unAgenciesNamesList[row.PartnerCode],
						agencyAbbreviation: unAgenciesShortNamesList[row.PartnerCode],
						allocations: []
					};
					Object.keys(cerfAllocationTypes).forEach(outerRow => {
						agencyObject[`cerf${separator}${outerRow}`] = 0;
					});
					populateAgencyObject(agencyObject, row);
					data.bar.push(agencyObject);
				};

			};
		});

		return data;

		function populateCountryObject(obj, row) {
			obj[`cerf${separator}0${separator}0`] += row.Budget;
			obj[`cerf${separator}0${separator}${row.ClusterId}`] += row.Budget;
			obj[`cerf${separator}${row.AllocationSurceId}${separator}0`] += row.Budget;
			obj[`cerf${separator}${row.AllocationSurceId}${separator}${row.ClusterId}`] += row.Budget;
			obj.allocations.push(row);
		};

		function populateAgencyObject(obj, row) {
			if (chartState.selectedCerfAllocation === "0") {
				obj[`cerf${separator}0`] += row.Budget;
				obj[`cerf${separator}${row.AllocationSurceId}`] += row.Budget;
			} else if (chartState.selectedCerfAllocation === row.AllocationSurceId.toString()) {
				obj[`cerf${separator}${row.AllocationSurceId}`] += row.Budget;
			};
			obj.allocations.push(row);
		};

		//end of processData
	};

	function createCsv(rawData) {

		const csvData = [];

		rawData.forEach(function(row) {
			if (chartState.selectedYear.indexOf(+row.AllocationYear) > -1) {
				csvData.push({
					Year: row.AllocationYear,
					Cluster: clustersList[row.ClusterId],
					Window: cerfAllocationTypes[row.AllocationSurceId],
					"Number of projects": row.NumbofProj,
					Fund: fundNamesList[row.PooledFundId],
					Agency: unAgenciesNamesList[row.PartnerCode],
					Budget: row.Budget
				});
			};
		});

		const csv = d3.csvFormat(csvData);

		return csv;
	};

	function setYearsDescriptionDiv(data) {
		yearsDescriptionDiv.html(function() {
			if (chartState.selectedYear.length === 1) return null;
			const total = d3.sum(data.map, d => d[`cerf${separator}0${separator}0`]);
			const valueSI = formatSIFloat(total);
			const unit = valueSI[valueSI.length - 1];
			const unitText = unit === "k" ? "Thousand" : unit === "M" ? "Million" : unit === "B" ? "Billion" : "";
			const totalNumber = +valueSI === +valueSI ? valueSI : valueSI.substring(0, valueSI.length - 1);
			const yearsList = chartState.selectedYear.sort(function(a, b) {
				return a - b;
			}).reduce(function(acc, curr, index) {
				return acc + (index >= chartState.selectedYear.length - 2 ? index > chartState.selectedYear.length - 2 ? curr : curr + " and " : curr + ", ");
			}, "");
			return `\u002A$${totalNumber} ${unitText} allocated in ${yearsList}`;
		});
	};

	function validateYear(yearString) {
		const allYears = yearString.split(",").map(function(d) {
			return +(d.trim());
		}).sort(function(a, b) {
			return a - b;
		});
		allYears.forEach(function(d) {
			if (d && yearsArray.indexOf(d) > -1) chartState.selectedYear.push(d);
		});
		if (!chartState.selectedYear.length) chartState.selectedYear.push(new Date().getFullYear());
	};

	function validateCustomEventYear(yearNumber) {
		if (yearsArray.indexOf(yearNumber) > -1) {
			return yearNumber;
		};
		while (yearsArray.indexOf(yearNumber) === -1) {
			yearNumber = yearNumber >= currentYear ? yearNumber - 1 : yearNumber + 1;
		};
		return yearNumber;
	};

	function capitalize(str) {
		return str[0].toUpperCase() + str.substring(1)
	};

	function parseTransform(translate) {
		const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
		group.setAttributeNS(null, "transform", translate);
		const matrix = group.transform.baseVal.consolidate().matrix;
		return [matrix.e, matrix.f];
	};

	function reverseFormat(s) {
		if (+s === 0) return 0;
		let returnValue;
		const transformation = {
			Y: Math.pow(10, 24),
			Z: Math.pow(10, 21),
			E: Math.pow(10, 18),
			P: Math.pow(10, 15),
			T: Math.pow(10, 12),
			G: Math.pow(10, 9),
			B: Math.pow(10, 9),
			M: Math.pow(10, 6),
			k: Math.pow(10, 3),
			h: Math.pow(10, 2),
			da: Math.pow(10, 1),
			d: Math.pow(10, -1),
			c: Math.pow(10, -2),
			m: Math.pow(10, -3),
			μ: Math.pow(10, -6),
			n: Math.pow(10, -9),
			p: Math.pow(10, -12),
			f: Math.pow(10, -15),
			a: Math.pow(10, -18),
			z: Math.pow(10, -21),
			y: Math.pow(10, -24)
		};
		Object.keys(transformation).some(function(k) {
			if (s.indexOf(k) > 0) {
				returnValue = parseFloat(s.split(k)[0]) * transformation[k];
				return true;
			}
		});
		return returnValue;
	};

	function wrapText(text, width) {
		text.each(function() {
			var text = d3.select(this),
				words = text.text().split(/\s+/).reverse(),
				word,
				line = [],
				lineNumber = 0,
				lineHeight = 1.1, // ems
				y = text.attr("y"),
				dy = parseFloat(text.attr("dy")),
				tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
			while (word = words.pop()) {
				line.push(word);
				tspan.text(line.join(" "));
				if (tspan.node().getComputedTextLength() > width) {
					line.pop();
					tspan.text(line.join(" "));
					line = [word];
					tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
				}
			}
		});
	};

	function wrapText2(text, width) {
		text.each(function() {
			let text = d3.select(this),
				words = text.text().split(/\s+/).reverse(),
				word,
				line = [],
				lineNumber = 0,
				lineHeight = 1.1,
				y = text.attr("y"),
				x = text.attr("x"),
				dy = 0,
				tspan = text.text(null)
				.append("tspan")
				.attr("x", x)
				.attr("y", y)
				.attr("dy", dy + "em");
			while (word = words.pop()) {
				line.push(word);
				tspan.text(line.join(" "));
				if (tspan.node()
					.getComputedTextLength() > width) {
					line.pop();
					tspan.text(line.join(" "));
					line = [word];
					tspan = text.append("tspan")
						.attr("x", x)
						.attr("y", y)
						.attr("dy", ++lineNumber * lineHeight + dy + "em")
						.text(word);
				}
			}
		});
	};

	function createFooterDiv() {

		let footerText = "© OCHA CERF Section " + currentYear;

		const footerLink = " | For more information, please visit <a href='https://pfbi.unocha.org'>pfbi.unocha.org</a>";

		if (showLink) footerText += footerLink;

		footerDiv.append("div")
			.attr("class", "d3chartFooterText")
			.html(footerText);

		//end of createFooterDiv
	};

	function createSnapshot(type, fromContextMenu) {

		const downloadingDiv = d3.select("body").append("div")
			.style("position", "fixed")
			.attr("id", classPrefix + "DownloadingDiv")
			.style("left", window.innerWidth / 2 - 100 + "px")
			.style("top", window.innerHeight / 2 - 100 + "px");

		const downloadingDivSvg = downloadingDiv.append("svg")
			.attr("class", classPrefix + "DownloadingDivSvg")
			.attr("width", 200)
			.attr("height", 100);

		const downloadingDivText = "Downloading " + type.toUpperCase();

		createProgressWheel(downloadingDivSvg, 200, 175, downloadingDivText);

		const svgRealSize = svg.node().getBoundingClientRect();

		svg.attr("width", svgRealSize.width)
			.attr("height", svgRealSize.height);

		const stackedSvgRealSize = stackedSvg.node().getBoundingClientRect();

		stackedSvg.attr("width", stackedSvgRealSize.width)
			.attr("height", stackedSvgRealSize.height);

		const listOfStyles = [
			"font-size",
			"font-family",
			"font-weight",
			"fill",
			"stroke",
			"stroke-dasharray",
			"stroke-width",
			"opacity",
			"text-anchor",
			"text-transform",
			"shape-rendering",
			"letter-spacing",
			"white-space",
			"dominant-baseline",
			"letter-spacing",
			"paint-order"
		];

		const imageDiv = containerDiv.node();

		setSvgStyles(svg.node());
		setSvgStyles(stackedSvg.node());

		if (fromContextMenu && currentHoveredElement) {
			if (tooltip.select("svg").size()) setSvgStyles(tooltip.select("svg").node());
			if (tooltipBar.select("svg").size()) setSvgStyles(tooltipBar.select("svg").node())
		};

		if (type === "png") {
			iconsDiv.style("opacity", 0);
		} else {
			topDiv.style("opacity", 0)
		};

		snapshotTooltip.style("display", "none");

		html2canvas(imageDiv).then(function(canvas) {

			svg.attr("width", null)
				.attr("height", null);

			if (type === "png") {
				iconsDiv.style("opacity", 1);
			} else {
				topDiv.style("opacity", 1)
			};

			if (type === "png") {
				downloadSnapshotPng(canvas);
			} else {
				downloadSnapshotPdf(canvas);
			};

			if (fromContextMenu && currentHoveredElement) d3.select(currentHoveredElement).dispatch("mouseout");

		});

		function setSvgStyles(node) {

			if (!node.style) return;

			let styles = getComputedStyle(node);

			for (let i = 0; i < listOfStyles.length; i++) {
				node.style[listOfStyles[i]] = styles[listOfStyles[i]];
			};

			for (let i = 0; i < node.childNodes.length; i++) {
				setSvgStyles(node.childNodes[i]);
			};
		};

		//end of createSnapshot
	};

	function downloadSnapshotPng(source) {

		const currentDate = new Date();

		const fileName = vizNameQueryString + "_" + csvDateFormat(currentDate) + ".png";

		source.toBlob(function(blob) {
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			if (link.download !== undefined) {
				link.setAttribute("href", url);
				link.setAttribute("download", fileName);
				link.style = "visibility:hidden";
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			} else {
				window.location.href = url;
			};
		});

		removeProgressWheel();

		d3.select("#" + classPrefix + "DownloadingDiv").remove();

	};

	function downloadSnapshotPdf(source) {

		const pdfMargins = {
			top: 10,
			bottom: 30,
			left: 20,
			right: 30
		};

		d3.image("./assets/img/UNOCHA_logo_vertical_blue_RGB.png")
			.then(function(logo) {

				let pdf;

				const point = 2.834646;

				const sourceDimentions = containerDiv.node().getBoundingClientRect();
				const widthInMilimeters = 210 - pdfMargins.left * 2;
				const heightInMilimeters = widthInMilimeters * (sourceDimentions.height / sourceDimentions.width);
				const maxHeightInMilimeters = 180;
				let pdfHeight;

				if (heightInMilimeters > maxHeightInMilimeters) {
					pdfHeight = 297 + heightInMilimeters - maxHeightInMilimeters;
					pdf = new jsPDF({
						format: [210 * point, (pdfHeight) * point],
						unit: "mm"
					})
				} else {
					pdfHeight = 297;
					pdf = new jsPDF();
				}

				let pdfTextPosition;

				createLetterhead();

				pdf.setTextColor(80, 80, 90);
				pdf.setFont('helvetica');
				pdf.setFontType("bold");
				pdf.setFontSize(14);
				pdf.text("Allocations", pdfMargins.left, 44);

				pdf.addImage(source, "PNG", pdfMargins.left, 48, widthInMilimeters, heightInMilimeters);

				const currentDate = new Date();

				//pdf.output("dataurlnewwindow");
				pdf.save(vizNameQueryString + "_" + csvDateFormat(currentDate) + ".pdf");

				removeProgressWheel();

				d3.select("#" + classPrefix + "DownloadingDiv").remove();

				function createLetterhead() {

					const footer = pdf.splitTextToSize("The mission of the United Nations Office for the Coordination of Humanitarian Affairs (OCHA) is to Coordinate the global emergency response to save lives and protect people in humanitarian crises. We advocate for effective and principled humanitarian action by all, for all.", (210 - pdfMargins.left - pdfMargins.right), {
						fontSize: 8
					});

					pdf.setFillColor(65, 143, 222);
					pdf.rect(pdfMargins.left, pdfMargins.top + 20, 210 - pdfMargins.right, 0.75, "F");
					pdf.rect(pdfMargins.left, pdfHeight - pdfMargins.bottom, 210 - pdfMargins.right, 0.75, "F");
					pdf.rect(pdfMargins.left + 22, pdfMargins.top + 2, 0.25, 15, "F");

					const fullDate = d3.timeFormat("%A, %d %B %Y")(new Date());

					pdf.setTextColor(35, 143, 222);
					pdf.setFontType("normal");
					pdf.setFontSize(14);
					pdf.text("CERF DATA HUB", pdfMargins.left + 26, 20);

					pdf.setTextColor(35, 143, 222);
					pdf.setFontType("normal");
					pdf.setFontSize(10);
					pdf.text(fullDate, pdfMargins.left + 26, 26.1);


					// pdf.setFillColor(236, 161, 84);
					// pdf.rect(0, pdfMargins.top + 15, 210, 2, "F");

					// pdf.setFillColor(255, 255, 255);
					// pdf.rect(pdfMargins.left, pdfMargins.top - 1, 94, 20, "F");

					// pdf.ellipse(pdfMargins.left, pdfMargins.top + 9, 5, 9, "F");
					// pdf.ellipse(pdfMargins.left + 94, pdfMargins.top + 9, 5, 9, "F");

					pdf.addImage(logo, "PNG", pdfMargins.left + 2, pdfMargins.top, 14, 18);

					// pdf.setFillColor(236, 161, 84);
					// pdf.rect(0, pdfHeight - pdfMargins.bottom, 210, 2, "F");

					pdf.setTextColor(35, 143, 222);
					pdf.setFont("helvetica");
					pdf.setFontType("normal");
					pdf.setFontSize(8);
					pdf.text(footer, 105, pdfHeight - pdfMargins.bottom + 6, {
						align: "center"
					});

					pdf.setTextColor(35, 143, 222);
					pdf.setFont("helvetica");
					pdf.setFontType("bold");
					pdf.setFontSize(8);
					pdf.text("www.unocha.org", 105, pdfHeight - pdfMargins.bottom + 16, {
						align: "center"
					});

				};

			});

		//end of downloadSnapshotPdf
	};

	function displayLabels(labelSelection) {
		labelSelection.each(function(d) {
			const outerElement = this;
			const outerBox = this.getBoundingClientRect();
			labelSelection.each(function(e) {
				if (outerElement !== this) {
					const innerBox = this.getBoundingClientRect();
					if (!(outerBox.right < innerBox.left ||
							outerBox.left > innerBox.right ||
							outerBox.bottom < innerBox.top ||
							outerBox.top > innerBox.bottom)) {
						if (e[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`] < d[`cerf${separator}${chartState.selectedCerfAllocation}${separator}0`]) {
							d3.select(this).style("display", "none");
						} else {
							d3.select(outerElement).style("display", "none");
						};
					};
				};
			});
		});
	};

	function formatSIFloat(value) {
		const length = (~~Math.log10(value) + 1) % 3;
		const digits = length === 1 ? 2 : length === 2 ? 1 : 0;
		let siString = d3.formatPrefix("." + digits, value)(value);
		if (siString[siString.length - 1] === "G") {
			siString = siString.slice(0, -1) + "B";
		};
		return siString;
	};

	function createProgressWheel(thissvg, thiswidth, thisheight, thistext) {
		const wheelGroup = thissvg.append("g")
			.attr("class", classPrefix + "d3chartwheelGroup")
			.attr("transform", "translate(" + thiswidth / 2 + "," + thisheight / 4 + ")");

		const loadingText = wheelGroup.append("text")
			.attr("text-anchor", "middle")
			.style("font-family", "Roboto")
			.style("font-weight", "bold")
			.style("font-size", "11px")
			.attr("y", 50)
			.attr("class", "contributionColorFill")
			.text(thistext);

		const arc = d3.arc()
			.outerRadius(25)
			.innerRadius(20);

		const wheel = wheelGroup.append("path")
			.datum({
				startAngle: 0,
				endAngle: 0
			})
			.classed("contributionColorFill", true)
			.attr("d", arc);

		transitionIn();

		function transitionIn() {
			wheel.transition()
				.duration(1000)
				.attrTween("d", function(d) {
					const interpolate = d3.interpolate(0, Math.PI * 2);
					return function(t) {
						d.endAngle = interpolate(t);
						return arc(d)
					}
				})
				.on("end", transitionOut)
		};

		function transitionOut() {
			wheel.transition()
				.duration(1000)
				.attrTween("d", function(d) {
					const interpolate = d3.interpolate(0, Math.PI * 2);
					return function(t) {
						d.startAngle = interpolate(t);
						return arc(d)
					}
				})
				.on("end", function(d) {
					d.startAngle = 0;
					transitionIn()
				})
		};

		//end of createProgressWheel
	};

	function removeProgressWheel() {
		const wheelGroup = d3.select("." + classPrefix + "d3chartwheelGroup");
		wheelGroup.select("path").interrupt();
		wheelGroup.remove();
	};

	//end of d3ChartIIFE
}());