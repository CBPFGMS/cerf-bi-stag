(function d3ChartIIFE() {

	//Important: D3 version is 5.x
	//All listeners using the arguments in the sequence: datum, index, node group

	const width = 1100,
		padding = [14, 8, 4, 4],
		panelHorizontalPadding = 4,
		buttonsPanelHeight = 30,
		buttonsNumber = 18,
		contributionsPanelHeight = 446,
		allocationsPanelHeight = 614,
		height = padding[0] + padding[2] + buttonsPanelHeight + panelHorizontalPadding + contributionsPanelHeight + allocationsPanelHeight,
		centralCircleRadiusRate = 0.18,
		unBlue = "#1F69B3",
		contributionColor = "#65A8DC",
		allocationColor = "#FBD45C",
		classPrefix = "cesank",
		countryNameMaxLength = 60,
		maxDonorsNumber = 20,
		maxOtherDonorsNumber = 20,
		othersId = "others",
		tooltipOthersId = "tooltipothers",
		othersName = "Others",
		fundId = "fund",
		maxOthersNumber = 30,
		maxYearsListNumber = 4,
		partnersPadding = 50,
		donorNamesPadding = 4,
		namesPadding = 10,
		valuesPadding = 18,
		collisionPadding = 4,
		angle = -45,
		minStrokeWidth = 1,
		minNodeWidth = 1,
		maxDonorTextLength = 120,
		donorValuesMeanLength = 33,
		otherFlagsNumber = 5,
		otherFlagsPadding = 4,
		tooltipWidth = 270,
		tooltipWidthAllocations = 300,
		memberStateString = "Member State",
		isTouchScreenOnly = (window.matchMedia("(pointer: coarse)").matches && !window.matchMedia("(any-pointer: fine)").matches),
		isBookmarkPage = window.location.hostname + window.location.pathname === "cbpfgms.github.io/cerf-bi-stag/bookmark.html",
		bookmarkSite = "https://cbpfgms.github.io/cerf-bi-stag/bookmark.html?",
		blankFlag = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
		fadeOpacity = 0.2,
		tooltipMargin = 8,
		circleWhiteBorder = 14,
		nodeWidth = 16,
		linksOpacity = 0.3,
		fadeOpacityNodes = 0.1,
		fadeOpacityLinks = 0.02,
		freeNodeSpace = (width - padding[1] - padding[3]) * (1 - 2 * centralCircleRadiusRate),
		windowHeight = window.innerHeight,
		currentDate = new Date(),
		currentYear = currentDate.getFullYear(),
		localVariable = d3.local(),
		localStorageTime = 3600000,
		duration = 1000,
		shortDuration = 250,
		flagSize = 24,
		flagSizeTooltip = 14,
		maxOthersNameLength = 32,
		flagPadding = 1,
		clusterIconsSize = 26,
		clusterIconsSizeTooltip = 16,
		clusterIconsPadding = 4,
		formatMoney0Decimals = d3.format(",.0f"),
		formatSIaxes = d3.format("~s"),
		formatNumberSI = d3.format(".3s"),
		clusterColorsArray = ["#F15B2C", "#F26222", "#F57F20", "#F9A11B", "#FEC010", "#D5A429", "#AA8C5C", "#5E5FAA", "#3D52A3", "#0073BD", "#71B4D3", "#7AC1BA", "#7FC88F", "#8CCA7B", "#A9D489", "#ADD255", "#C4C070", "#D39A6D", "#D16F5F", "#ED1C24"],
		allYearsOption = "all",
		chartTitleDefault = "Sankey diagram",
		vizNameQueryString = "sankey",
		allocationsDataUrl = "https://cbpfgms.github.io/pfbi-data/allocationSummarySankey.csv",
		contributionsDataUrl = "https://cbpfgms.github.io/pfbi-data/contributionSummarySankey.csv",
		masterDonorsUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstDonor.json",
		masterFundsUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstCountry.json",
		masterAllocationTypesUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstAllocation.json",
		masterUnAgenciesUrl = "https://cerfgms-webapi.unocha.org/v1/agency/All.json",
		masterPartnersUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstOrganization.json",
		masterClustersUrl = "https://cbpfgms.github.io/pfbi-data/mst/MstClusterCBPFCERF.json",
		flagsUrl = "./assets/img/flags24.json",
		csvDateFormat = d3.utcFormat("_%Y%m%d_%H%M%S_UTC"),
		yearsArray = [],
		yearsArrayAllocations = [],
		yearsArrayContributions = [],
		lists = {
			donorNames: {},
			donorIsoCodes: {},
			donorTypes: {},
			fundNames: {},
			fundRegions: {},
			fundAbbreviatedNames: {},
			fundIsoCodes: {},
			fundIsoCodes3: {},
			allocationTypes: {},
			partnerTypes: {},
			unAgencyNames: {},
			unAgencyShortNames: {},
			clusterNames: {},
			clusterShortNames: {}
		},
		separator = "##",
		chartState = {
			selectedYear: [],
			selectedFund: []
		};

	let isSnapshotTooltipVisible = false,
		cerfPooledFundId,
		currentHoveredElement;

	const clustersIconsData = {
	1: "data:image/png;base64,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",
	2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAtCAYAAADoSujCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEYElEQVRogdWXX0xbZRjGf++hIAUdm24xCwHTMi80xAtYtBcmZVUDcbJpBBbjjFtixCiJUrLsTsKVmUkBE6Mj8ca4+Qc2FyYxUQKli5mLgRi98cbCJHMmZmHgxh8LPa8XUIECpedwSspz+Z33+d7nd877fWmFDMjf+Xu5oVKHylOKekEeQHQa5C/gF+ByLPbvt1dPP3Jnq71k63GXFfjg+qNqxkMo1Yik3FvRCVF5z5ySDyNtnjm7PR0DCLSPvaFidoDkW/Gp8quKHI00e67b6WvYMa0bRPR9q+EBRHjMUP0pEIo+bqevcwBwClW1ZRb2mYZ8X9Ux+oRVq2MAQ83eLhNeV9S04xcoAr7zh8Z8Fn3Oyt8efU2ELkFsvRyFKTWlJtLiuZZOveMAsL0QGQGA7YNw7AwkKxIs+0Sgye7BFigSQ3tRTfmSMwYAEG4u+xjhLdu3kzKMSEpvRgFgEUJFzlg2KgNz6qrbrCzjAAA5ol9b9ajonl3gBqjsGs6t6hh9t6oz+mJy3bYAxKHUqkeQipgx3x/ojD5438yerwTaxKSnqmO0cXVdhuULjbvzjfkfBKmw41d0WpDC5QVVwXhzMOg5C9vwBUpKSmKC/GbXvyo8gIgo5keBzmjT4vMMyRcadxcQ9w22eML+1rBLdpeeF6TBsQaqisiJjAD4QuPufFnoFeGQqfpSJFh2wd8adhlFpecQOeZUH1W96fgIrQj/DOAyRL7wt0frIm2HFsyp8eOgXy4nYEBMCShM2eklEHMcwG0stCyFT2gVxN5i7yKEMjCrrtrBFk8YqLYKoapxUSPoOMA/BRNnFL2UtPw/RE+DxPcWe4/Pqqv2WkvpLMC+yZmfgZF0e6hqHHh1sMVzyZEz4AuNu93GQo8pejbyTllfZddw7uLdLS8klS6gZnU4eGAwsVDfrTm3boxeQOR5K+GHgmXnwYFrNDHzwGFRuejvjD430nhw/k7B7WNrvoQSmdW8H1cuTdwcrbAbfssASQcWgTxRuRhoj9augVia+cTYJPTkbe+IKj12wi/1dCb8qmYQM1TrBoNl31R2Defumrn/9KzpCiWHT8jfGnZJ0UOfi1BvJbxtgKWZvww8vVGNQgylYSjo7U1nz/puzbn159inwMur9lGNC3IyHPR+tp7P8gitmPkNw8PiOIE2pqpZqZ4GiZuTf5xQtDuxlnjzG4Vf6pO+Uo3NGikDhYX3HOlrLJ6x0qO+W3P+vjF60hDKMczu8NsPX01VnzZAOmOTkKpe0bzZw5Gm8rvp7m9XaQFka3hIAyCbw8MmANkeHlIA7ITwsAHATgkP6wDspPCQBLDTwsMKAKvhc+MFz/af2j+d0XRpSGDnhgeQnRwewJVvzHeBbBoeZeDewvwjfY37Lf22ybQMIY1/QzZ/mG2HDJRIyoosDg9gmCKvAMPrPVTVK664+2i2hoelW8jfMbbbQPuBg4kH2Xhg15MBEGn2TBquvBqUPpS7KOfmNLcm28MD/Ac0rl/qXg0VxwAAAABJRU5ErkJggg==",
	3: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAA7CAYAAAA9xQlEAAAACXBIWXMAAAsTAAALEwEAmpwYAAACWUlEQVRoge2av2tTURSAv/OSWLCgFrolQ0pc/BfEYiIqUnRw6OzYQQnaTRARHSyIDXWQ2k0noU7S2R/YxUWobtW86qBd/VG1oXnvOLRSTZ7pizftfa/cb0rePfdwP7jnnpdLpFLzFZuoXn46Xpr41/Dxifr+oE8+Rww1gRlv+1a27WRVdSzNAohIJtUCANn2RzoVKnMAGQ8JQ7kmwuGdXlhc2gRC4dHzS6X539/LNf8YJFcg9VvICdgmcQKn733c2018xCm08xy5+2Eg1wjOoIyu/GicrEzWPwGPQ49ZVnnTaW4CBOR8bjW4jpBDQABEikDVU6rBHl3qNNu+gFDoPC5DnYYTVwPd4gRs4wRsk3oB82NUWUNYAKJ+9v1HPj240QdiYSSgylfP0+EnF0uvTfK0Uqn5V4AbcWKNtpDAbK8XDzCYH7qJshIn1rQGDhjOj+Tb8tt+oC9OrJGAip4t1/yxE7eW+03y/MnRqcVCI8jcR8jFiTeqAUE8YLqZ/TldqfkmqTYJ2Xiji0fqj1EnYBvjRqaqDzzxHgYarvViQag36El4FZFDccLNBJT5Z+Olc0Y5Ihi+8/5lthnUEdmynM22kNDzJgbwolpcAr7EiTUTUB05NbW4zyhHBJXb70YQidUkzbaQSLERZBbKk/6coN+Ncm3mLCiMxm0F5m+jIkWBC111n61SdhGb+mPUCdjGCdjGCdjGCdjGCdjGCdjGCdjGCdjGCdhm9wmISv7vJ5pvjUkS0vq3S0VD0fVLJUUyIvT83qeXtF2rCOIhDKx/Tj67rwbShKKvfgFZK5MCBawJXgAAAABJRU5ErkJggg==",
	4: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFNklEQVRoge1ZXWxURRg9Z3YXqqj8tUSSUtilYGOIMcKDJsC2S8Co0cQoTTQxJIQHAsR2KQUUBaoQwba7LRpME+MLkICFGHmByM9miVETiWjiD3/dBQJiFGJr+O/uPT5QSrvdvezeXakPPU/3znxzvnPunTszd4b4DzC38eKIbte11SQXQ5CgNk/ywU0H6sdfLXQuFpRNYqA1/qolNRKc2L9KvxNsmN3l/bShgVahUhbMQCB05inBagUx0y5OwvcusuZQ0PttIfLmbWDOR+fHWt031wpYStKVVSNJIrar26yMrvT+kU9+xwamtx31PHx1zBIQDQRGOuEQdJVA03CT/GB/zdSbTjgcGQiE489ZssIkH7uHwC9uJ+HLtnHSCUMTPBz07stVS04GZrecnmIss5HE/FwEBZrjVRbVQuKJe6Q4CCVrI8un/JKtpqwMzG28OCLhvlYvcTWJ4TbK/xa5uaTzWri9YdqtvlX+dRG3GTlxIYANIEoyc6Ab0CeuW1h7cPXkrvwMSKxqib8BaDPARzPnlAVghyehFQfqy/+0o5y59exoz43EepBLALgzp9ZlgO+XlHo/bq9mMmcD/tDpGQS3kHzGThCgKCzWROp8P9nHpfA3xSuMsVpAPmvLDv0goiZaO/nrdPUDDMwKnRnvZnK9gEUEjQ3zeRBrIrXebSDVT9y6iNuMLHsX4EIBHlI7r1uet76rK7ueShMIdbwooBWkN3MuSeBut9GKg7WTz6U10DssAu+ReCQjGXQdwhZr2PUN0WXTrqSLqAx3rCG4IaV4ayToW5ou/unmcw8UmcSbFN4B8ZCNj2skGq1Osyna4L3Ra6AqHHtJQojE5MzCAUGfu4n61KeQiqpQ7CSIKf2T4x9/l3e03TJiVtOpCW5jGgFUg8zYvSV0kFgeCfr2sioUWwGi0U4QpB9B1kSCviO2cT2oDHUcT50jBHT5O71jslkHVYVjsyG1gnzSVhZUZ0Cssom5JGBxcalvRrbiAQDEtoFF2J7tIi4S9B0pLvXNELAYwCWbRKvcAIrT1CQAfWYlu9dEV1TYEKSHOs9t5qgyD8CFgDwSdt6Q5+1cOHqGzjZ/OL7LyFotMkhgWD/5wDhWhWMa0FrJabnMhvcDgdYzj8uyBmhKO0z+38QDwOGaSb+mK884EzqBv/lUOY3rFQhzSFQA6umevCThOIhDNIndkZqpHYXKWRAD/taTpUy6PwRUTcB1d3bpvZhAYgKAuUq6NlaGY7uM5V55uK7sQr65M8+0WaIqFJtnLPcxEq9l80ND0kXgdTFxLNDSMTff/HkZqGyO+UF9iTsjmTRwQEjFnRiiRMLeQKhjVj4aHBuY13xuDA12AywCAEEXLJnn79WONC8I6uk6LBK4xx+Oj3Kqw7GBbtO9Fj1PXtJlmqQ/Wufdf692h4PefbKsytvLZQBECaG1TnU4MjB/3c/DICy4c09wSS4jS7RuymnJLLtbogXT2456nGhxZOCv0UWzQN5+7VK8uNS7J1eOcRMmtQs6CwAEx4y8MtZ2OyYTnHUhmfLea/Ibuz+mTGivZpJA796QjMrt4jPBoYE+2yjCCUccAAT+1ufW0YfsyABdiT2STkg6YeDa4YQDAGgSO3p55Mq5GwIOZ+KeD7bCSdtC8+Q9Ew82hgwMNoYM2CES9DES9BX2ECUFQ29gsDFkYLAxZGCwMWRgsDFkYLBhBPQ7TZTg6MD5fiCdVkMgdd8/+3MAmyR9H0S6MidIp9UggUUSDkC4Iugrt9GiPJM0QbhCoMmuzBHSaP0XYBkfLLhiquwAAAAASUVORK5CYII=",
	5: "data:image/png;base64,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",
	6: "data:image/png;base64,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",
	7: "data:image/png;base64,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",
	8: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAnCAYAAABJ0cukAAAACXBIWXMAAAsTAAALEwEAmpwYAAAENElEQVRYhe1ZXWgcVRg9Z2ay2/zUvkSwfwnJSuiDDyoBi6ZmExuoNC+CodD4JLXB2rjN1jbagmExCpIwmzQqpOIPCAr+IBoLhSzNtokUWksfLEhrd9KWNhGNtBVCNsnOfD4ku2w2G3cmY7MGe16Wvff7zvkOc+98d+8SLrGj94o3bqmdBJpFIAQ+K7079eZXoUdm3HLbgeaWIG6qb5F8DQBIAED7H+uKLABH3HLbgeKWgMQLdsbuFVwbgOChRUMiG1zz2oR7A3nGfQP5xn0D+caqN+C6kTlFfXj0WRE5DmLTcjkEcguClmjQd2LZBrZ1/7pZU5WDqf6bBgKKP2zooiT004Gqmxni/W6Kn+PnRqH0A9jkeAnVdo9u8YeNj1VVvQowkF2BJNBGS4v5deOjBXMiropPSYAbIULbT6A2PPooYQUh1m6Cqj0ReEC8CJE9IGX55S6NnAZqe2I1isV2QBoBAosWTH6R1UBHhyjD64ydQhyBcOt/reh0LDDQ1HHJM/HAmuYzinEY4JZ7JSrA74AcU4gBD83LJwNV07lyGrrGi6cZr1IVaQTQCuJBYN5AQ9d4sanFX5oQOej2DZET5DfatOyJvO676yRt8ND6SQAXAVzc0XulN25qnwCA5tdjOxOc+hRAqdOlIoIbJMqyTAiAayArMqeevlOxKxSi5e+5+gwspZ3EYwBKc2pBJik4DzJ8MlD5fUeHNEVJUUC8b5PAAvAzgA9gSXPCNMuiwcry+WIzYmENBX2VlpLYDFi7099AoRCtOt3opCgREg12tAGAYDFIP4Dv/LrxTihECwA0gkv0AolD+JMQIxAZESo/Rtsq7tgRS2K+iX2RPlbbE2uE4KgTnkyQeKNej509FfQNaCLyMokPBfASPAuREUvBSCHN83Y2l2NxYVvqi+AHVZFXIgd8N3Llbe+7vsGcNftBNM6lIghgQIsGfScArNhPQAiqk3tNLVBbIq3lY3bSIq3lY9v7rreYCfPW3AirgTycRglZmypqf9m4k9xIa/lYas8RJRBZav2vHqx6A64PCXV6zAIXHqlFxIwGfYuOKXW6MQyixq1mSgcYXuEnIE/9m2wUqVn1SyhvBkTkqJYoLAHE1h3qUvF5MzAzO9M3eGj9pFUw1ecmPm8GPB7Pq7XvXSpRZgtb3cSv+K1EEgQ7OVvU6Tb+/72J63Rjb2YPAOauVep0Y68bbrtYViNr+lLUiZvG2yDb/zlSjv9VdHv/hZbqWQDwh40zBLYtR3MJ/tOODTz57i9rvQXez5PH2pwSgsHEGnXXyL7y28mx9O49dKBCsXvlki3P8RLyFniHFhQvMiqQbgG20pInRKQLIqPJaRINBfHEqQWmwJm5Tzj6IzBbnuO3kFD+hOAyyG+pWF8PBR6+kBFyDsDhev3a4xas50l5DsRv6QEEuiEIkDjm5MIrW97fd1Of+s4MDIEAAAAASUVORK5CYII=",
	9: "data:image/png;base64,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",
	10: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFOElEQVRoge1YXWwUZRQ9ZxZpaEwoJsaoaNhuIYEor/jAzy5FA0FSBQsYhZoA4UVhdzYRJGohxuBD7RQfrGJ46IMJlMSARDAI+9OCmvhkIjFBdmpC0AewCAiVlp3jQ0vDtjOzu53RxoTzNt+9595zkvm+784QIWNpR+FZiWslLQIxEwAIXJTQK6A7b8ZOhdmPYRVqbCvMKRr4jORi/0zli9SWnmTDL2H0DcVAwrIXQzoCckZFBOkqgaaMGesN2juwgca2whzHwPcVix+BoH45zoJ8evaFIP2NIGQAKEbwSbXiAYDgQ6RxIGh/Nrf+NPVyXe0eSBtHlroevnZr9+E9Tw2WI49s2JNBBIjOslyy4XS5PC+dUy7X1e4hsBMcfZveujy9FgB2lW3ucF3Ql5DiWgBlDXjpNAi1jCtKvVZJc0ELqxHrgTKn1jC8dBoAH3VJd1lzK8rHK8nzhTizskR3nYE3cVAIcILwAxkQdCkIHwAYsEYgAyQDX0QAeoKQAxlwpENB+MNQdxB2IAN5M3ZKQGbiFZTPmg0B+KHcxMZmAFeq5Qnqdxxnc9D+gQ30bpvVR2m1oP5KOYL6DeGFoHMQEIIBAMiYsV6HegZSrlyuoKwcZ0EYkygATAmjCACMzPeJeMeFRoprISwC+MRwVBdB9EI6lAv4zo9FaAbuYmQwKzvbhIWyBpZYfXURYb2o37LJ6DGQ+lcVSUx09K2i+FiROJhPRf/0S/fdA8v3na8x5HwrqhPA0XiH3dXcrUiogu9Bc7ci8Q67C8BRUZ2Uc3b5vvM1fhxfA0OKzAc59+4zwQ1XLtkHWlsV+gzV2irjyiX7AMENo/3IeQNF42k/nr+QSI0N4EbpIlt6pvfthxTaDwFI7Jnetx9gS+kyrtdoqu1H9TVw+o2Zf0jYAGGoJEBsSlh2ZygmJCYsuxPEptJ1DAHYeDL9pO/94mkgbtk7ACBn1h8FnfUA7pQkkFvjlv1pIBMS41bfRyC3li6r6Igbc2b9UQCIt9utPgY04BagtDdu2VsBIJtq+ELAq5KKpR64JdFhWxPVn+iwLRKvjxUP8pV8OnoQABKW/TaJ3e4VNGAI/M41RhLQxwnrwssAkEvVHwLQMtYEwO0Jy26rWrxltwHcPk480DLSC/H2wi4A73lX4VmDKm4TcM01DBqQ0RVvL6wEgJwZ+xzAuy6p6UR74YOKxQ/npsf1I94Z6YFEe2Enyfe9aki4DhWTRtacfS4CrsC402bUxQMkDicse/Ew0XA/FcgdcatglhMf/7CQBrnDVRRoA0C83X4T5F6fMjcYKa7ImrPPjW7AJR2FhYbDEyAedOdoAOJxQI0g6zwK3ymC83tS0Z/dgkv3/TpPjvMjvCYA6aqIHwg+5yld+MsxtCKfjJ0B7jmF8snYGRArBd10Z3IaiDU+4gFgSgRO0rO346Q8xQMAOcNPvKCbEp6/K77EAABkU/U9hmOsknTLR6QvJDb6BJdNvK5uGY6xKpeuz9+7Pu4eyKSjWQFNXsdrBa28/ykRj0yoonCbUnMmHc2OjbleZHkzdopEE6C/q21GstYnOq3aegIGAa3JphuOu8U9b+JMMvYNxAmZCAsCBg3ppZwZ+8orx3cWypr1Jx3HeFHC7fDl+UPAIIHmjBk75pdXdizOp6NfG+R/a0IYErgum6r/slxqRXN9JhU9QTmrvW7sMCHgGsmmfCp6pJL8ij9MsumG40UZc8tnBkNRxtxMKnqi0vyqvqx6zVm/Vy+pOlTbY9J/rwfFfQOTjfsGJhv3DUw2/vcG/gEn4Sfa3kOf1wAAAABJRU5ErkJggg==",
	11: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADBklEQVRoge2ZTWhTWRiGn/eYabWOXQguxqp0qoioC0EZyoCmEcQBBWdhXQwKItKuRGOXLurGYWawiX+gFcGFunEjDAXbjb8VhNGVVkRJqtafjah00dZq7udCw6QhSZPQ1FPIuzqc7/3O+Z577r3n5EaUoZZY8k9Eh6Cm1FyDccHR69GmQ+XMna1QSyyxBdEt1JAxy0tJbdeiP1/NlSTYRxnFf8ut4Wv+lAA4oTMTiv86yyLDugtUccJgvJwJDcYxTpSTm7OUSDxp+YLXo00qZbBcY5U6RqlylRx8OlQF+N6a8QAFH+LplY2a6TWyF5h6AxdcuXVg2dPJsjwCyCGjJ+WCg4VA/L6FxFYXuAfh+ODufBa/AQCJWoedj8QTh3PFvQf4X+oMxxJ7s3tnEAAInQp3PV2W2TezAEStnDuS2TejAABktGauQqiQudIHsUw1d72YM9t93iDsGGhFXqMkx6zfgaPg0Qrc7VgyeiPa1De3bvZasMcFzWJzuukNQFo97Q0jQeCik9ga0w3vAADm/Vhzq1DczBam214C9LQ3jBSKS6pLtx3Gyzy+oSmtqkIKSWozs7OIRRn9Q0Ggtu9RUEsseUfi18l8kXjSMPqn7TVZrEo9HXv5DJSiKsCUy+gv3srtSpZSVVVVTZFaYol/IvHE37li3m1k2dp4LLHJAvoAJLcl+5O/1wC/HX9S/zEVGsg45gzVus+re/cvH057/NsHMjSWCv2VdUZbPJYKTfhN7O0KhLsGm+WCO0ITLrJhgYnwzQNL+8HTFejsNOcUnM4uHkDIuYCTmAk8BbhR/2wH0pq8BmlNJD7YCh7eQq2XbdbbV8mHBb9MAAZP7MPzVd6twNtXiR2TFQ8gWE5943bvAMy0q1ivc7bTOwDgl2KNZtbsHYCk4v9Al0LeAYANFG9lwDsAC7hQrFeyi94BLBgePYdxvwjrveG69+e82wcA1see/RRS8C+wLlfcjP9SuG23Dza+8RIAYG33vR/mjczfg9kfklYCmNkjoUvDc9+dv9++7hPAF0Z96GNzO74WAAAAAElFTkSuQmCC",
	12: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADiklEQVRogc1ZTU8TURQ9ZwbDD5AdSkIxLgyJ7HBHYWWiiQsxRCWRjRATv4q/wxZdCRtdFA2JCzUaXWFZqTsWxgWGIRFZGxMTUMscF7Sknc7Hm/bZ9uzmzX2957x3b++8+zhxf2tcjpYguQJzpfnMS3QxsnnvAqGCQNeBbnK84H0FcKLyvixgupTLrHSSZBSyBW+KQBFADwAI2nEguTU2PQSK2YI31RmK0QiSr6Ds+HTmAZRrBrtORBR5gredtdzgC1+6jIAISMtjC5vT7aXaiIkF71KQvKR9STPvc5lXrA5GqYzKiWx+8xyIRYoiObuaG3ybhpjJfBNOTnW0lMusCJiGYTgRfESwH8QxQYtpyJvMN11Qp3ZSKZdZMQ4n4ljN0/G0AuLmx4VNMBrqBADA2vzQ86AIki59PGlHTkwseJckPEWAPIBrpfmh5aB9gwCgcyLSkgciBADtF9EMeSBGAHAgIpjYJF1HfGyBcx2C5AGUQV6NIw8kCABiEts+EhM2DIkCgPBw+l8wCZtahK7kYZEB+62yMwBJF0BxvOAVDweF71HFLnQHDotMtyCmWBqFkAG2U88QvttwHL4D5GwKB9u+z9m0jm35YNhgKzj7YKN3z++Zo3RFxDAAUPgMcLnXLS+9u3Pyt01/VgVM3P/W7zt/3xA8HWogrVNHzq/eG9ix5dOagIOVdz9Fkq9CWu9198/Y2glbSYw9v2cukTwAkCN/5F635deaAABXTQ0lc9skWBNA4ZSxsThsy6/NHTCGAN/Wb1kTIOKLqS0pY9sk2AyhYrJVxZYw+lAzgTUBvW55CdJ6oqG0fvTH7pItv9YLmfj3NciRUIP/UMisJvHqvYGdvp+7o6RuAfoI4ReEX5I+kLrV93N31CZ5IGIHUp0HYr7V42DLR+vngVYbWy36sBVCrTa2moaN80A7EHkeCD0TV2Ktod0X0vqwDkn7cjCzdnfIqK4YhVC7yAPpm2eJArIFbyq06WQfDc0zk0uWWAFxXeJWmIah2UuWSAHN9iqbRbO92FAB7SZfRTMiGgR0inwVaUXUCYhM2LAucX2daLWxVTc/riseTOxDAWkv+WqKXauNrdD5pnd2BDofNnEYy29OOuQzBP8JK8WO2bx3gcRzGK58JxAZHcKkA+Bhw4suIg9EhxOovAOoq8lXES6CZYfkDQnfIG0BuNiN5Kso5TIrEiYFeQI2BM79A7D9dwIFdOgTAAAAAElFTkSuQmCC",
	13: "data:image/png;base64,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",
	14: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD3klEQVRoge2ZQWgcVRjH//+dyW4TaiqYeEkQOhWlRz16cfegBFpPprGFtAdzsFJqNi00QltLQ5FUMJtN8FCVoI2gzV4riD1kT8VbPQhCaHYRmksaxNradHdn5u8h7u402dnskqGzK/md9n3fN+/7f7Nv3ps3j2gD4p8vnyVxAcCNnn7rVGaITtkXCVFXw5BMgnwe5AdrK7nvjizIKPvaogAQ1z2No94i6I07fG2l6y/Hjj1bddvTtU4WWUqRPFG16oeePmu4UkBiajkN4DRI1uijJZH0lVlt8n0QbSMeAAgeqxQgapLiKCCz3kVhITJCYN8m6xdtccePLMhYu5f/BsRw1aovF5PWybaYhdZW8jNe8YJmF5PWSZBqiwIEHfL8ns0mrVGQAtplHRDOQ/gN0GWv+F12CQACQHwq9zOJt8IW0wwSbmXPWG9HAKDdxANVze0xC9Uh8AIErAq64IKvmXbnXtPu3Os4fB3ARQGrQecL9L1HQqZYKozcHj/4cJPrDoA7b1z9PR2LxuYADAaVM7ACJGSyY/vfq7fI3B4/+BDSUGI6v4CAighkCAlYLZYKIw2tkKRiEXsEwv0gctcsQEBRwrhhGn2GafQJ+FhA0b8bzdQYNr78NPrK3wBmfXtrIr/fEPoke8b6zNO+Gk/lAGCyVjBd3mxQewXH5U3D0MRO89f8BxxFrm+2qcRv/cS4scfL9eVuxXae3PXzNZO/ZgGxjq37YsMwjFqxAFD6x2h6Y9S9x/+aZvLXLMC2neObbWJpi61MR3TPAT+fH+tuh+Xnaya/3zMwEU/lYJrGPAA4JfuEyMt+tywCHQbw6zaan75GeqfOJ4SG8xMAEqncjjYIAlaLxcLLjc5EA+ml7oJj3gXRu5O8i2MWA1kHCLwYi8bmIG3/LEgsOObcTsWXCfJdaDAxnV8YSC91+wUMpJe6E6l8BsS7QSUN+hvQYMEx30xM5WaJyI9O9NFSdP0FOUbhVcE9VHDxEYieIBMG/xFrY2hMCO5EpNQF21wPPIWX/8d+QMKtsIU0Sztq3qUleXrhkZiYzl2SOAxiJjtmzYSkq2Gqs5DE+HQuDfASiQMELoaoq2E2CvhPPMHTHt+NcCQ1h1lLvISMHvyRDFNYozAxtTwJctxrFPCAkhuWqPrQBjGzOGZdAQAT4KktIcA+tPZh5TkAVwAgIuj7kMU0hSBXwNflttnbb324tpJ7DuBRT9B81O1IPu5Uy52E2Ot88svZlypviAQ2TgHv38vPkzjmif10ccw6/8wVNkkEADJDdHr79x+XUBlOkvdIs3WpLGTlIiBdE/QnoekwhTXKvx//eq77xCqaAAAAAElFTkSuQmCC",
	15: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClklEQVRoge2ZMVMTQQCF39uLpYW2kBkTkBb/AEOg0MLGcWAyjhRWoWQSLPwRwFFYAI0NOBOk0EothGT8A7aKhCIZO8ZR23DPRpy7S4DbkOMIc1+3d/d237vd272dJWKisHLwEMQ6RZEs7ZZz7+Nox8RRKQAQXCM4BGJY0Hpc7cQWAMSwr5SNq5n4AlwSaYCkSQMkTcZfmF4+nJLRBiRHYLlWyb9LypifSffwkZHngmzTY2l3Mbd3ci/QAzLaADAKMkdip+A2ipfuNkTBbRQN9AbkHQCjYnBNCQ4hyfGVMgQ2kwxRcBtFApvwjRQx4DEYwKOpAGj7LiUWopt5AG2IFf9zgQD1cu6tJz1BKASkrcnVg7n47AaZXm3Mdrx56VjSs/B32TEL1SsjOwLm4AtB0jHiK6ueEFq+UjOqrOA2ihJeI/zmyae1yshW+Pmu02itnK+GQ8ByOJEs/QvR9DyWoprvNmwEzNXK+WrXdnqqUJjp9xQ75X5/DJhqR1tnmAfOWchO6wlQKxez2w2+hKV5IMJK3D0E26cK+kMk80DEX4laOV+VMCOoIeCbwPmLewxCYV7SDwBND5yNYj4lJeUacOZCdhoTS/vZjHFcEPcB3Lyghz+QPoF8sVfOf7UVWweYWNrPOo75QvC2rfZMpJ9tzxv//Pxu5P8moIctZcZxVvpuHgDIW45xlm1lveyJH/Sgia3uq7WpJ2QrsQ4g4YOtxqL2j7YK+wBOuyLpyFZ3br3Skczxoq3OOkB9YaxldGNc0LaAX7b6MBJ+C9qWc3yvvjDWOl+RktJX+P8oCBxK2owVQotkKUNwDcBgmQdwcnRlQkdBg0b2aq3EPZAGSJo0QNKkAZLmGgQIHkQMGk3jO4gYNJqex9Jf29X9bgr5aTsAAAAASUVORK5CYII=",
	16: "data:image/png;base64,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",
	17: "data:image/png;base64,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",
	get 18(){
		return this[6];
	},
	19: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEBklEQVRoge2aS2hcZRTHf+fO2GShbaHWB5SYF8Fg8UFEqdRMJrYwboRsBBe1uBMF87ASDWoMgkRaM4mQheBCi7uqLbgwSmCSqHGjUHwgmWSSGEUouGiN2Ewyc/8u0kkmk0ycezNhEskPLnO/7zvnO/8D93syBhAZiJctuIEzJjuNUQUE2ZmkBNOg8+VO+txQa13SIgPxsqQb+AIsVGp1XhCKlTvpx4NJN/gSsKvEAxgWTrqBDkdwqtRitsDTjkF1qVX4x2oddu6ALYSgU2oFW2UvgVKzl0Cp2fUJbDqFSvrDsM8xQkBtfkOWMH0C3LnBlmRe0kUzFjZ2NgdoWte/mAR9gxEBu8NzAoLFoMOx4bbquUfe/uWWffv2/WjYXRvZuui50faa9wGaoolPDWtZbbMnRjuqR/LFAYgMxPcvpINxM24HkLiyuJRsGO+snw9FZyodNJlPa/5PSPw23FYzBzDeWT+PrDufqWP21WqHzlh2W9PVyrH1HmsZaq37CzSdKRu6PN5ZPw8w2l41K/Fr3tj5Ggzc7PLhI1UfCX7eyDZt7oqti9b49fSYu95jlYb3vrspHJ16CuPhTJ1yYudqyabgbcSFJy0dis68auhioT65hPsSA5i9sKbyn+Uf89mnp1lotL3qkqRvfcbaFjxPo2b28nYI8YvnBGLt1WNCX26HGD/4WsjMUReSii3GDwUnEOqfOpp5j7XWfi/sY6/BBHFgOPsRigmuee0rQ8GzkOM6nZGB+PPLczaY8RrQ4qWPkY6aQWAwt/5Ef6IiJfvB4EChfa3oKtRQ6FAyHXgxU461V08AH3gNuBHDbTVzBj/58fU4Bqzj5Nmp2zIl10n1gPLscQqn+Z3EQ6AGP77ezsPGzamgdQFtAKOtdb+Ho9ODUNh4bopOvw46vaZSFnRNR2x5U+cZz06SPRs+O72yqXPTi71yg38X4mvSIcOq1zxGhV/x4ONGwowyAnoDeAZg9Mzdf/oNXgx8ZS44Fe6bvKfYYvzgbyEzC8icN4stxg++vz3DWh6Lzhwrphg/bOlMnJbbWywhftlSAmbW2NyfOFksMX7Im4By2iyPrWRvIa2eR7T2bNLdrVU/s0AhonJj5WrJZrMjZUUoOlMJcKI3cUBmD+QxfTDUP5u9ODVmN44cnG0ECHXHgkLH/0P7DcF2f2Qgvh/g0Xdnq8zY8DIBwMLR6bzLqMQVMw1JdtyMmk0iLgk+wzho0JzTOi90CbjXsPsKSeBG7ISZvpYskrmt8JzAbmDX38ztJVBq9hIoNf+LBFKlFrEFUs7yfw92K5pyQOdLLcM34kOn3EmfQxoptRavCMVuvXa9zxlqrUuWBdIRUJekCXb2mEhJmkB65fDV65ELPUcX/wW0BlTDTcpO8gAAAABJRU5ErkJggg==",
	20: "data:image/png;base64,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",
	21: "data:image/png;base64,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",
	22: "data:image/png;base64,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",
	get 23(){
		return this[6]
	}
	};

	const clusterNamesScale = d3.scaleOrdinal()
		.domain(["Food Security",
			"Health",
			"Emergency Shelter and NFI",
			"Water Sanitation Hygiene",
			"Protection",
			"Nutrition",
			"Logistics",
			"Education",
			"COVID-19",
			"Coordination and Support Services",
			"Camp Coordination / Management",
			"Early Recovery",
			"Multi-Sector",
			"Multi-Purpose cash",
			"Emergency Telecommunications",
			"Mine Action",
			"Agriculture",
			"Food Assistance",
			"Shelter and Non-Food Items",
			"Common Services",
			"Multi-Sector Refugee Assistance",
			"To be determined",
			"Multi-purpose CASH",
			"Food Aid"
		])
		.range(["Food Security",
			"Health",
			"Emergency Shelter",
			"Water Sanitation",
			"Protection",
			"Nutrition",
			"Logistics",
			"Education",
			"COVID-19",
			"Coordination and Support",
			"Camp Coordination",
			"Early Recovery",
			"Multi-Sector",
			"Multi-Purpose cash",
			"Emergency Telecommunications",
			"Mine Action",
			"Agriculture",
			"Food Assistance",
			"Shelter & Non-Food Items",
			"Common Services",
			"Refugee Assistance",
			"To be determined",
			"Multi-purpose CASH",
			"Food Aid"
		]);

	const queryStringValues = new URLSearchParams(location.search);

	if (!queryStringValues.has("viz")) queryStringValues.append("viz", vizNameQueryString);

	const containerDiv = d3.select("#d3chartcontainer" + classPrefix);

	const showLink = containerDiv.node().getAttribute("data-showlink") === "true";

	const chartTitle = containerDiv.node().getAttribute("data-title") ? containerDiv.node().getAttribute("data-title") : chartTitleDefault;

	const selectedResponsiveness = containerDiv.node().getAttribute("data-responsive") === "true";

	const lazyLoad = containerDiv.node().getAttribute("data-lazyload") === "true";

	const selectedYearString = queryStringValues.has("year") ? queryStringValues.get("year").replace(/\|/g, ",") : containerDiv.node().getAttribute("data-year");

	if (selectedResponsiveness === false) {
		containerDiv.style("width", width + "px")
			.style("height", height + "px");
	};

	const topDiv = containerDiv.append("div")
		.attr("class", classPrefix + "TopDiv");

	const titleDiv = topDiv.append("div")
		.attr("class", classPrefix + "TitleDiv");

	const iconsDiv = topDiv.append("div")
		.attr("class", classPrefix + "IconsDiv d3chartIconsDiv");

	const svg = containerDiv.append("svg")
		.attr("viewBox", "0 0 " + width + " " + height)
		.style("background-color", "white");

	const yearsDescriptionDiv = containerDiv.append("div")
		.attr("class", classPrefix + "YearsDescriptionDiv");

	const footerDiv = containerDiv.append("div")
		.attr("class", classPrefix + "FooterDiv");

	const snapshotTooltip = containerDiv.append("div")
		.attr("id", classPrefix + "SnapshotTooltip")
		.attr("class", classPrefix + "SnapshotContent")
		.style("display", "none")
		.on("mouseleave", () => {
			isSnapshotTooltipVisible = false;
			snapshotTooltip.style("display", "none");
			tooltip.style("display", "none");
		});

	snapshotTooltip.append("p")
		.attr("id", classPrefix + "SnapshotTooltipPdfText")
		.html("Download PDF")
		.on("click", () => {
			isSnapshotTooltipVisible = false;
			createSnapshot("pdf", true);
		});

	snapshotTooltip.append("p")
		.attr("id", classPrefix + "SnapshotTooltipPngText")
		.html("Download Image (PNG)")
		.on("click", () => {
			isSnapshotTooltipVisible = false;
			createSnapshot("png", true);
		});

	const browserHasSnapshotIssues = !isTouchScreenOnly && (window.safari || window.navigator.userAgent.indexOf("Edge") > -1);

	if (browserHasSnapshotIssues) {
		snapshotTooltip.append("p")
			.attr("id", classPrefix + "TooltipBestVisualizedText")
			.html("For best results use Chrome, Firefox, Opera or Chromium-based Edge.")
			.attr("pointer-events", "none")
			.style("cursor", "default");
	};

	const tooltip = containerDiv.append("div")
		.attr("id", classPrefix + "tooltipdiv")
		.style("display", "none");

	containerDiv.on("contextmenu", function() {
		d3.event.preventDefault();
		const thisMouse = d3.mouse(this);
		isSnapshotTooltipVisible = true;
		snapshotTooltip.style("display", "block")
			.style("top", thisMouse[1] - 4 + "px")
			.style("left", thisMouse[0] - 4 + "px");
	});

	const buttonsPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "buttonsPanel")
			.attr("transform", "translate(" + padding[3] + "," + padding[0] + ")"),
		width: width - padding[1] - padding[3],
		height: buttonsPanelHeight,
		padding: [0, 0, 0, 0],
		buttonWidth: 54,
		buttonsMargin: 4,
		buttonsPadding: 6,
		buttonVerticalPadding: 4,
		arrowPadding: 18
	};

	const contributionsPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "mapPanel")
			.attr("transform", "translate(" + padding[3] + "," + (padding[0] + buttonsPanel.height + panelHorizontalPadding) + ")"),
		width: width - padding[1] - padding[3],
		height: contributionsPanelHeight,
		padding: [116, 0, 0, 0],
	};

	const allocationsPanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "mapPanel")
			.attr("transform", "translate(" + padding[3] + "," + (padding[0] + buttonsPanel.height + contributionsPanel.height + (2 * panelHorizontalPadding)) + ")"),
		width: width - padding[1] - padding[3],
		height: allocationsPanelHeight,
		padding: [0, 0, 64, 0],
	};

	const centralCirclePanel = {
		main: svg.append("g")
			.attr("class", classPrefix + "mapPanel")
			.attr("transform", "translate(" + (padding[3] + (width - padding[1] - padding[3]) / 2) + "," + (padding[0] + buttonsPanel.height + contributionsPanel.height + (2 * panelHorizontalPadding)) + ")"),
		radius: (width - padding[1] - padding[3]) * centralCircleRadiusRate
	};

	const defs = svg.append("defs");

	const centralCircleGradient = defs.append("linearGradient")
		.attr("id", classPrefix + "centralCircleGradient")
		.attr("x1", "0%")
		.attr("y1", "0%")
		.attr("x2", "0%")
		.attr("y2", "100%");

	centralCircleGradient.append("stop")
		.attr("offset", "0%")
		.attr("stop-color", contributionColor);

	centralCircleGradient.append("stop")
		.attr("offset", "100%")
		.attr("stop-color", allocationColor);

	const sankeyGeneratorContributions = d3.sankey()
		.nodeSort(null)
		.linkSort((a, b) => a.value - b.value)
		.nodeWidth(nodeWidth)
		.nodePadding(null)
		.nodeId(d => d.id)
		.extent([
			[contributionsPanel.padding[0], 0],
			[contributionsPanel.height - contributionsPanel.padding[2], 2 * centralCirclePanel.radius]
		]);

	const sankeyGeneratorAllocations = d3.sankey()
		.nodeSort(null)
		.linkSort((a, b) => a.value - b.value)
		.nodeWidth(nodeWidth)
		.nodePadding(null)
		.nodeId(d => d.id)
		.extent([
			[allocationsPanel.padding[0], 0],
			[allocationsPanel.height - allocationsPanel.padding[2], 2 * centralCirclePanel.radius]
		]);

	const clusterColorsScale = d3.scaleOrdinal();

	const inverseContributionsScale = d3.scaleLinear()
		.domain([0, contributionsPanel.width - contributionsPanel.padding[1] - contributionsPanel.padding[3]])
		.range([contributionsPanel.width - contributionsPanel.padding[1] - contributionsPanel.padding[3], 0]);

	const inverseAllocationsScale = d3.scaleLinear()
		.domain([0, allocationsPanel.width - allocationsPanel.padding[1] - allocationsPanel.padding[3]])
		.range([allocationsPanel.width - allocationsPanel.padding[1] - allocationsPanel.padding[3], 0]);

	Promise.all([
			fetchFile(classPrefix + "MasterDonors", masterDonorsUrl, "master table for donors", "json"),
			fetchFile(classPrefix + "MasterFunds", masterFundsUrl, "master table for funds", "json"),
			fetchFile(classPrefix + "MasterAllocationTypes", masterAllocationTypesUrl, "master table for allocation types", "json"),
			fetchFile(classPrefix + "MasterPartnerTypes", masterPartnersUrl, "master table for partner types", "json"),
			fetchFile(classPrefix + "MasterUnAgencies", masterUnAgenciesUrl, "master table for un agencies", "json"),
			fetchFile(classPrefix + "MasterClusterTypes", masterClustersUrl, "master table for cluster types", "json"),
			fetchFile(classPrefix + "AllocationsData", allocationsDataUrl, "allocations data", "csv"),
			fetchFile(classPrefix + "contributionsData", contributionsDataUrl, "contributions data", "csv"),
			fetchFile(classPrefix + "flags", flagsUrl, "flags images", "json")
		])
		.then(allData => fetchCallback(allData));

	function fetchCallback([
		masterDonors,
		masterFunds,
		masterAllocationTypes,
		masterPartners,
		masterUnAgencies,
		masterClusters,
		rawDataAllocations,
		rawDataContributions,
		flagsData
	]) {

		createDonorNamesList(masterDonors);
		createFundNamesList(masterFunds);
		createAllocationTypesList(masterAllocationTypes);
		createPartnerTypesList(masterPartners);
		createUnAgenciesNamesList(masterUnAgencies);
		createClustersList(masterClusters);

		//CERF as the only fund
		chartState.selectedFund.push(cerfPooledFundId);

		preProcessData(rawDataAllocations, rawDataContributions);

		validateYear(selectedYearString);

		if (!lazyLoad) {
			draw(rawDataAllocations, rawDataContributions, flagsData);
		} else {
			d3.select(window).on("scroll." + classPrefix, checkPosition);
			d3.select("body").on("d3ChartsYear." + classPrefix, () => chartState.selectedYear = [validateCustomEventYear(+d3.event.detail)]);
			checkPosition();
		};

		function checkPosition() {
			const containerPosition = containerDiv.node().getBoundingClientRect();
			if (!(containerPosition.bottom < 0 || containerPosition.top - windowHeight > 0)) {
				d3.select(window).on("scroll." + classPrefix, null);
				draw(rawDataAllocations, rawDataContributions, flagsData);
			};
		};

		//end of fetchCallback
	};

	function draw(rawDataAllocations, rawDataContributions, flagsData) {

		//test panels
		// buttonsPanel.main.append("rect")
		// 	.attr("width", buttonsPanel.width)
		// 	.attr("height", buttonsPanel.height)
		// 	.style("fill", "blue")
		// 	.style("opacity", 0.2);
		// contributionsPanel.main.append("rect")
		// 	.attr("width", contributionsPanel.width)
		// 	.attr("height", contributionsPanel.height)
		// 	.style("fill", "blue")
		// 	.style("opacity", 0.2);
		// allocationsPanel.main.append("rect")
		// 	.attr("width", allocationsPanel.width)
		// 	.attr("height", allocationsPanel.height)
		// 	.style("fill", "blue")
		// 	.style("opacity", 0.2);
		// centralCirclePanel.main.append("circle")
		// 	.attr("r", centralCirclePanel.radius)
		// 	.style("fill", "blue")
		// 	.style("opacity", 0.2);
		//test panels

		const dataAllocations = processDataAllocations(rawDataAllocations);

		const dataContributions = processDataContributions(rawDataContributions);

		createTitle(rawDataAllocations, rawDataContributions);

		createButtonsPanel(rawDataAllocations, rawDataContributions, flagsData);

		drawCentralCircle(dataContributions, dataAllocations);

		drawSankeyContributions(dataContributions, flagsData);

		drawSankeyAllocations(dataAllocations);

		setYearsDescriptionDiv();

		//end of draw;
	};

	function createTitle(rawDataAllocations, rawDataContributions) {

		const title = titleDiv.append("p")
			.attr("id", classPrefix + "d3chartTitle")
			.html(chartTitle);

		//NO HELP ICON FOR NOW
		// const helpIcon = iconsDiv.append("button")
		// 	.attr("id", classPrefix + "HelpButton");

		// helpIcon.html("HELP  ")
		// 	.append("span")
		// 	.attr("class", "fa fa-info")

		const downloadIcon = iconsDiv.append("button")
			.attr("id", classPrefix + "DownloadButton");

		downloadIcon.html(".CSV  ")
			.append("span")
			.attr("class", "fa fa-download");

		const snapshotDiv = iconsDiv.append("div")
			.attr("class", classPrefix + "SnapshotDiv");

		const snapshotIcon = snapshotDiv.append("button")
			.attr("id", classPrefix + "SnapshotButton");

		snapshotIcon.html("IMAGE ")
			.append("span")
			.attr("class", "fa fa-camera");

		const snapshotContent = snapshotDiv.append("div")
			.attr("class", classPrefix + "SnapshotContent");

		const pdfSpan = snapshotContent.append("p")
			.attr("id", classPrefix + "SnapshotPdfText")
			.html("Download PDF")
			.on("click", function() {
				createSnapshot("pdf", false);
			});

		const pngSpan = snapshotContent.append("p")
			.attr("id", classPrefix + "SnapshotPngText")
			.html("Download Image (PNG)")
			.on("click", function() {
				createSnapshot("png", false);
			});

		const playIcon = iconsDiv.append("button")
			.datum({
				clicked: false
			})
			.attr("id", classPrefix + "PlayButton");

		playIcon.html("PLAY  ")
			.append("span")
			.attr("class", "fa fa-play");

		playIcon.on("click", function(d) {
			d.clicked = !d.clicked;

			playIcon.html(d.clicked ? "PAUSE " : "PLAY  ")
				.append("span")
				.attr("class", d.clicked ? "fa fa-pause" : "fa fa-play");

			if (d.clicked) {
				chartState.selectedYear.length = 1;
				loopButtons();
				timer = d3.interval(loopButtons, 3 * duration);
			} else {
				timer.stop();
			};

			function loopButtons() {
				const index = yearsArray.indexOf(chartState.selectedYear[0]);

				chartState.selectedYear[0] = yearsArray[(index + 1) % yearsArray.length];

				const yearButton = d3.selectAll("." + classPrefix + "buttonsRects")
					.filter(function(d) {
						return d === chartState.selectedYear[0]
					});

				yearButton.dispatch("click");

				if (yearsArray.length > buttonsNumber) {

					const firstYearIndex = chartState.selectedYear[0] < yearsArray[buttonsNumber / 2] ?
						0 :
						chartState.selectedYear[0] > yearsArray[yearsArray.length - (buttonsNumber / 2)] ?
						yearsArray.length - buttonsNumber :
						yearsArray.indexOf(chartState.selectedYear[0]) - (buttonsNumber / 2);

					const currentTranslate = -(buttonsPanel.buttonWidth * firstYearIndex);

					if (currentTranslate === 0) {
						svg.select("." + classPrefix + "LeftArrowGroup").select("text").style("fill", "#ccc")
						svg.select("." + classPrefix + "LeftArrowGroup").attr("pointer-events", "none");
					} else {
						svg.select("." + classPrefix + "LeftArrowGroup").select("text").style("fill", "#666")
						svg.select("." + classPrefix + "LeftArrowGroup").attr("pointer-events", "all");
					};

					if (Math.abs(currentTranslate) >= ((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth)) {
						svg.select("." + classPrefix + "RightArrowGroup").select("text").style("fill", "#ccc")
						svg.select("." + classPrefix + "RightArrowGroup").attr("pointer-events", "none");
					} else {
						svg.select("." + classPrefix + "RightArrowGroup").select("text").style("fill", "#666")
						svg.select("." + classPrefix + "RightArrowGroup").attr("pointer-events", "all");
					};

					svg.select("." + classPrefix + "buttonsGroup").transition()
						.duration(duration)
						.attrTween("transform", function() {
							return d3.interpolateString(this.getAttribute("transform"), "translate(" + currentTranslate + ",0)");
						});
				};
			};
		});

		if (!isBookmarkPage) {

			const shareIcon = iconsDiv.append("button")
				.attr("id", classPrefix + "ShareButton");

			shareIcon.html("SHARE  ")
				.append("span")
				.attr("class", "fa fa-share");

			const shareDiv = containerDiv.append("div")
				.attr("class", "d3chartShareDiv")
				.style("display", "none");

			shareIcon.on("mouseover", function() {
					shareDiv.html("Click to copy")
						.style("display", "block");
					const thisBox = this.getBoundingClientRect();
					const containerBox = containerDiv.node().getBoundingClientRect();
					const shareBox = shareDiv.node().getBoundingClientRect();
					const thisOffsetTop = thisBox.top - containerBox.top - (shareBox.height - thisBox.height) / 2;
					const thisOffsetLeft = thisBox.left - containerBox.left - shareBox.width - 12;
					shareDiv.style("top", thisOffsetTop + "px")
						.style("left", thisOffsetLeft + "20px");
				}).on("mouseout", function() {
					shareDiv.style("display", "none");
				})
				.on("click", function() {

					const newURL = bookmarkSite + queryStringValues.toString();

					const shareInput = shareDiv.append("input")
						.attr("type", "text")
						.attr("readonly", true)
						.attr("spellcheck", "false")
						.property("value", newURL);

					shareInput.node().select();

					document.execCommand("copy");

					shareDiv.html("Copied!");

					const thisBox = this.getBoundingClientRect();
					const containerBox = containerDiv.node().getBoundingClientRect();
					const shareBox = shareDiv.node().getBoundingClientRect();
					const thisOffsetLeft = thisBox.left - containerBox.left - shareBox.width - 12;
					shareDiv.style("left", thisOffsetLeft + "20px");

				});

		};

		if (browserHasSnapshotIssues) {
			const bestVisualizedSpan = snapshotContent.append("p")
				.attr("id", classPrefix + "BestVisualizedText")
				.html("For best results use Chrome, Firefox, Opera or Chromium-based Edge.")
				.attr("pointer-events", "none")
				.style("cursor", "default");
		};

		snapshotDiv.on("mouseover", function() {
			snapshotContent.style("display", "block")
		}).on("mouseout", function() {
			snapshotContent.style("display", "none")
		});

		//helpIcon.on("click", null); //CHANGE THIS

		downloadIcon.on("click", function() {

			const csvAllocations = createCsvAllocations(rawDataAllocations);

			const csvContributions = createCsvContributions(rawDataContributions);

			const currentDate = new Date();

			const fileNameAllocations = "Allocations_" + csvDateFormat(currentDate) + ".csv";

			const fileNameContributions = "Contributions_" + csvDateFormat(currentDate) + ".csv";

			const blobAllocations = new Blob([csvAllocations], {
				type: 'text/csv;charset=utf-8;'
			});

			const blobContributions = new Blob([csvContributions], {
				type: 'text/csv;charset=utf-8;'
			});

			if (navigator.msSaveBlob) {
				navigator.msSaveBlob(blobAllocations, fileNameAllocations);
				navigator.msSaveBlob(blobContributions, fileNameContributions);
			} else {

				const linkAllocations = document.createElement("a");

				if (linkAllocations.download !== undefined) {

					const urlAllocations = URL.createObjectURL(blobAllocations);

					linkAllocations.setAttribute("href", urlAllocations);
					linkAllocations.setAttribute("download", fileNameAllocations);
					linkAllocations.style = "visibility:hidden";

					document.body.appendChild(linkAllocations);

					linkAllocations.click();

					document.body.removeChild(linkAllocations);

				};

				const linkContributions = document.createElement("a");

				if (linkContributions.download !== undefined) {

					const urlContributions = URL.createObjectURL(blobContributions);

					linkContributions.setAttribute("href", urlContributions);
					linkContributions.setAttribute("download", fileNameContributions);
					linkContributions.style = "visibility:hidden";

					document.body.appendChild(linkContributions);

					linkContributions.click();

					document.body.removeChild(linkContributions);

				};
			};

		});

		//end of createTitle
	};

	function createButtonsPanel(rawDataAllocations, rawDataContributions, flagsData) {

		const clipPath = buttonsPanel.main.append("clipPath")
			.attr("id", classPrefix + "clip")
			.append("rect")
			.attr("width", buttonsNumber * buttonsPanel.buttonWidth)
			.attr("height", buttonsPanel.height);

		const clipPathGroup = buttonsPanel.main.append("g")
			.attr("class", classPrefix + "ClipPathGroup")
			.attr("transform", "translate(" + (buttonsPanel.padding[3]) + ",0)")
			.attr("clip-path", "url(#" + classPrefix + "clip)");

		const buttonsGroup = clipPathGroup.append("g")
			.attr("class", classPrefix + "buttonsGroup")
			.attr("transform", "translate(0,0)")
			.style("cursor", "pointer");

		const buttonsRects = buttonsGroup.selectAll(null)
			.data(yearsArray)
			.enter()
			.append("rect")
			.attr("rx", "2px")
			.attr("ry", "2px")
			.attr("class", classPrefix + "buttonsRects")
			.attr("width", buttonsPanel.buttonWidth - buttonsPanel.buttonsMargin)
			.attr("height", buttonsPanel.height - buttonsPanel.buttonVerticalPadding * 2)
			.attr("y", buttonsPanel.buttonVerticalPadding)
			.attr("x", function(_, i) {
				return i * buttonsPanel.buttonWidth + buttonsPanel.buttonsMargin / 2;
			})
			.style("fill", function(d) {
				return chartState.selectedYear.indexOf(d) > -1 ? unBlue : "#eaeaea";
			});

		const buttonsText = buttonsGroup.selectAll(null)
			.data(yearsArray)
			.enter()
			.append("text")
			.attr("text-anchor", "middle")
			.attr("class", classPrefix + "buttonsText")
			.attr("y", buttonsPanel.height / 1.6)
			.attr("x", function(_, i) {
				return i * buttonsPanel.buttonWidth + buttonsPanel.buttonWidth / 2;
			})
			.style("fill", function(d) {
				return chartState.selectedYear.indexOf(d) > -1 ? "white" : "#444";
			})
			.text(function(d) {
				return d;
			});

		const leftArrow = buttonsPanel.main.append("g")
			.attr("class", classPrefix + "LeftArrowGroup")
			.style("cursor", "pointer")
			.style("opacity", 0)
			.attr("pointer-events", "none")
			.attr("transform", "translate(" + buttonsPanel.padding[3] + ",0)");

		const leftArrowRect = leftArrow.append("rect")
			.style("fill", "white")
			.attr("width", buttonsPanel.arrowPadding)
			.attr("height", buttonsPanel.height - buttonsPanel.padding[0] - buttonsPanel.buttonVerticalPadding * 2)
			.attr("y", buttonsPanel.buttonVerticalPadding);

		const leftArrowText = leftArrow.append("text")
			.attr("class", classPrefix + "leftArrowText")
			.attr("x", 0)
			.attr("y", buttonsPanel.height - buttonsPanel.buttonVerticalPadding * 2.1)
			.style("fill", "#666")
			.text("\u25c4");

		const rightArrow = buttonsPanel.main.append("g")
			.attr("class", classPrefix + "RightArrowGroup")
			.style("cursor", "pointer")
			.style("opacity", 0)
			.attr("pointer-events", "none")
			.attr("transform", "translate(" + (buttonsPanel.padding[3] + buttonsPanel.arrowPadding +
				(buttonsNumber * buttonsPanel.buttonWidth)) + ",0)");

		const rightArrowRect = rightArrow.append("rect")
			.style("fill", "white")
			.attr("width", buttonsPanel.arrowPadding)
			.attr("height", buttonsPanel.height - buttonsPanel.padding[0] - buttonsPanel.buttonVerticalPadding * 2)
			.attr("y", buttonsPanel.buttonVerticalPadding);

		const rightArrowText = rightArrow.append("text")
			.attr("class", classPrefix + "rightArrowText")
			.attr("x", -1)
			.attr("y", buttonsPanel.height - buttonsPanel.buttonVerticalPadding * 2.1)
			.style("fill", "#666")
			.text("\u25ba");

		if (yearsArray.length > buttonsNumber) {

			clipPathGroup.attr("transform", "translate(" + (buttonsPanel.padding[3] + buttonsPanel.arrowPadding) + ",0)")

			rightArrow.style("opacity", 1)
				.attr("pointer-events", "all");

			leftArrow.style("opacity", 1)
				.attr("pointer-events", "all");

			repositionButtonsGroup();

			checkCurrentTranslate();

			leftArrow.on("click", function() {
				leftArrow.attr("pointer-events", "none");
				const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];
				rightArrow.select("text").style("fill", "#666");
				rightArrow.attr("pointer-events", "all");
				buttonsGroup.transition()
					.duration(duration)
					.attr("transform", "translate(" +
						Math.min(0, (currentTranslate + buttonsNumber * buttonsPanel.buttonWidth)) + ",0)")
					.on("end", checkArrows);
			});

			rightArrow.on("click", function() {
				rightArrow.attr("pointer-events", "none");
				const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];
				leftArrow.select("text").style("fill", "#666");
				leftArrow.attr("pointer-events", "all");
				buttonsGroup.transition()
					.duration(duration)
					.attr("transform", "translate(" +
						Math.max(-((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth),
							(-(Math.abs(currentTranslate) + buttonsNumber * buttonsPanel.buttonWidth))) +
						",0)")
					.on("end", checkArrows);
			});
		};

		buttonsRects.on("mouseover", mouseOverButtonsRects)
			.on("mouseout", mouseOutButtonsRects)
			.on("click", function(d) {
				const self = this;
				if (d3.event.altKey) {
					clickButtonsRects(d, false);
					return;
				};
				if (localVariable.get(this) !== "clicked") {
					localVariable.set(this, "clicked");
					setTimeout(function() {
						if (localVariable.get(self) === "clicked") {
							clickButtonsRects(d, true);
						};
						localVariable.set(self, null);
					}, 250);
				} else {
					clickButtonsRects(d, false);
					localVariable.set(this, null);
				};
			});

		d3.select("body").on("d3ChartsYear." + classPrefix, function() {
			clickButtonsRects(validateCustomEventYear(+d3.event.detail), true);
			if (yearsArray.length > buttonsNumber) repositionButtonsGroup();
			checkArrows();
		});

		function checkArrows() {

			const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];

			if (currentTranslate === 0) {
				leftArrow.select("text").style("fill", "#ccc");
				leftArrow.attr("pointer-events", "none");
			} else {
				leftArrow.select("text").style("fill", "#666");
				leftArrow.attr("pointer-events", "all");
			};

			if (Math.abs(currentTranslate) >= ((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth)) {
				rightArrow.select("text").style("fill", "#ccc");
				rightArrow.attr("pointer-events", "none");
			} else {
				rightArrow.select("text").style("fill", "#666");
				rightArrow.attr("pointer-events", "all");
			}

		};

		function checkCurrentTranslate() {

			const currentTranslate = parseTransform(buttonsGroup.attr("transform"))[0];

			if (currentTranslate === 0) {
				leftArrow.select("text").style("fill", "#ccc")
				leftArrow.attr("pointer-events", "none");
			};

			if (Math.abs(currentTranslate) >= ((yearsArray.length - buttonsNumber) * buttonsPanel.buttonWidth)) {
				rightArrow.select("text").style("fill", "#ccc")
				rightArrow.attr("pointer-events", "none");
			};

		};

		function repositionButtonsGroup() {

			const firstYearIndex = chartState.selectedYear[0] < yearsArray[buttonsNumber / 2] ?
				0 :
				chartState.selectedYear[0] > yearsArray[yearsArray.length - (buttonsNumber / 2)] ?
				yearsArray.length - buttonsNumber :
				yearsArray.indexOf(chartState.selectedYear[0]) - (buttonsNumber / 2);

			buttonsGroup.attr("transform", "translate(" +
				(-(buttonsPanel.buttonWidth * firstYearIndex)) +
				",0)");

		};

		function mouseOverButtonsRects(d) {
			tooltip.style("display", "block")
				.html(null)

			const innerTooltip = tooltip.append("div")
				.style("max-width", "200px")
				.attr("id", classPrefix + "InnerTooltipDiv");

			innerTooltip.html("Click for selecting a single year. Double-click or ALT + click for selecting multiple years.");

			const containerSize = containerDiv.node().getBoundingClientRect();

			const thisSize = this.getBoundingClientRect();

			tooltipSize = tooltip.node().getBoundingClientRect();

			tooltip.style("left", (thisSize.left + thisSize.width / 2 - containerSize.left) > containerSize.width - (tooltipSize.width / 2) - padding[1] ?
					containerSize.width - tooltipSize.width - padding[1] + "px" : (thisSize.left + thisSize.width / 2 - containerSize.left) < tooltipSize.width / 2 + buttonsPanel.padding[3] + padding[0] ?
					buttonsPanel.padding[3] + padding[0] + "px" : (thisSize.left + thisSize.width / 2 - containerSize.left) - (tooltipSize.width / 2) + "px")
				.style("top", (thisSize.top + thisSize.height / 2 - containerSize.top) < tooltipSize.height ? thisSize.top - containerSize.top + thisSize.height + 2 + "px" :
					thisSize.top - containerSize.top - tooltipSize.height - 4 + "px");

			d3.select(this).style("fill", unBlue);
			buttonsText.filter(function(e) {
					return e === d
				})
				.style("fill", "white");
		};

		function mouseOutButtonsRects(d) {
			tooltip.style("display", "none");
			if (chartState.selectedYear.indexOf(d) > -1) return;
			d3.select(this).style("fill", "#eaeaea");
			buttonsText.filter(function(e) {
					return e === d
				})
				.style("fill", "#444");
		};

		function clickButtonsRects(d, singleSelection) {

			if (singleSelection) {
				chartState.selectedYear = [d];
			} else {
				const index = chartState.selectedYear.indexOf(d);
				if (index > -1) {
					if (chartState.selectedYear.length === 1) {
						return;
					} else {
						chartState.selectedYear.splice(index, 1);
					}
				} else {
					chartState.selectedYear.push(d);
				};
			};

			const allYears = chartState.selectedYear.map(function(d) {
				return d;
			}).join("|");

			if (queryStringValues.has("year")) {
				queryStringValues.set("year", allYears);
			} else {
				queryStringValues.append("year", allYears);
			};

			buttonsRects.style("fill", function(e) {
				return chartState.selectedYear.indexOf(e) > -1 ? unBlue : "#eaeaea";
			});

			buttonsText.style("fill", function(e) {
				return chartState.selectedYear.indexOf(e) > -1 ? "white" : "#444";
			});

			setYearsDescriptionDiv();

			const dataAllocations = processDataAllocations(rawDataAllocations);

			const dataContributions = processDataContributions(rawDataContributions);

			//CALL DRAWING FUNCTIONS HERE
			drawCentralCircle(dataContributions, dataAllocations);

			drawSankeyContributions(dataContributions, flagsData);

			drawSankeyAllocations(dataAllocations);

			//end of clickButtonsRects
		};

		//end of createButtonsPanel
	};

	function drawCentralCircle(dataContributions, dataAllocations) {

		const centralCircleBackground = centralCirclePanel.main.selectAll("." + classPrefix + "centralCircleBackground")
			.data([true])
			.enter()
			.append("circle")
			.attr("class", classPrefix + "centralCircleBackground")
			.attr("r", centralCirclePanel.radius + circleWhiteBorder)
			.style("fill", "white");

		const centralCircle = centralCirclePanel.main.selectAll("." + classPrefix + "centralCircle")
			.data([true])
			.enter()
			.append("circle")
			.attr("class", classPrefix + "centralCircle")
			.attr("r", centralCirclePanel.radius)
			.attr("fill", "url(#" + classPrefix + "centralCircleGradient)");

		const centralLine = centralCirclePanel.main.selectAll("." + classPrefix + "centralLine")
			.data([true])
			.enter()
			.append("line")
			.attr("class", classPrefix + "centralLine")
			.attr("x1", -centralCirclePanel.radius * 0.5)
			.attr("x2", centralCirclePanel.radius * 0.5);

		const contributionsValue = dataContributions.nodes.length ? dataContributions.nodes.find(e => e.level === 2).value : 0;
		const allocationsValue = dataAllocations.nodes.length ?dataAllocations.nodes.find(e => e.level === 1).value : 0;

		let contributionsValueText = centralCirclePanel.main.selectAll("." + classPrefix + "contributionsValueText")
			.data([contributionsValue]);

		const contributionsValueTextEnter = contributionsValueText.enter()
			.append("text")
			.attr("class", classPrefix + "contributionsValueText")
			.attr("y", -centralCirclePanel.radius * 0.4)
			.text("$")
			.append("tspan")
			.attr("class", classPrefix + "contributionsValueTextSpan")
			.transition()
			.duration(duration)
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent) || 0, d);
				return t => d ? formatSIFloat(interpolator(t)) : 0;
			});

		contributionsValueText.select("tspan")
			.transition()
			.duration(duration)
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent) || 0, d);
				return t => d ? formatSIFloat(interpolator(t)) : 0;
			});

		const contributionsText = centralCirclePanel.main.selectAll("." + classPrefix + "contributionsText")
			.data([true])
			.enter()
			.append("text")
			.attr("class", classPrefix + "contributionsText")
			.attr("y", -centralCirclePanel.radius * 0.26)
			.text("Contributions");

		let contributionsSubText = centralCirclePanel.main.selectAll("." + classPrefix + "contributionsSubText")
			.data([true]);

		contributionsSubText = contributionsSubText.enter()
			.append("text")
			.attr("class", classPrefix + "contributionsSubText")
			.attr("y", -centralCirclePanel.radius * 0.14)
			.merge(contributionsSubText)
			.text(() => {
				if (chartState.selectedYear.length === 1) return "for " + chartState.selectedYear[0];
				if (chartState.selectedYear.length > maxYearsListNumber) return "for selected years\u002A";
				const yearsList = chartState.selectedYear.sort((a, b) => a - b)
					.reduce((acc, curr, index) => acc + (index >= chartState.selectedYear.length - 2 ? index > chartState.selectedYear.length - 2 ? curr : curr + " and " : curr + ", "), "");
				return "for " + yearsList;
			});

		let allocationsValueText = centralCirclePanel.main.selectAll("." + classPrefix + "allocationsValueText")
			.data([allocationsValue]);

		const allocationsValueTextEnter = allocationsValueText.enter()
			.append("text")
			.attr("class", classPrefix + "allocationsValueText")
			.attr("y", centralCirclePanel.radius * 0.3)
			.text("$")
			.append("tspan")
			.attr("class", classPrefix + "allocationsValueTextSpan")
			.transition()
			.duration(duration)
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent) || 0, d);
				return t => d ? formatSIFloat(interpolator(t)) : 0;
			});

		allocationsValueText.select("tspan")
			.transition()
			.duration(duration)
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent) || 0, d);
				return t => d ? formatSIFloat(interpolator(t)) : 0;
			});

		const allocationsText = centralCirclePanel.main.selectAll("." + classPrefix + "allocationsText")
			.data([true])
			.enter()
			.append("text")
			.attr("class", classPrefix + "allocationsText")
			.attr("y", centralCirclePanel.radius * 0.44)
			.text("Allocations");

		let allocationsSubText = centralCirclePanel.main.selectAll("." + classPrefix + "allocationsSubText")
			.data([true]);

		allocationsSubText = allocationsSubText.enter()
			.append("text")
			.attr("class", classPrefix + "allocationsSubText")
			.attr("y", centralCirclePanel.radius * 0.56)
			.merge(allocationsSubText)
			.text(() => {
				if (chartState.selectedYear.length === 1) return "in " + chartState.selectedYear[0];
				if (chartState.selectedYear.length > maxYearsListNumber) return "in selected years\u002A";
				const yearsList = chartState.selectedYear.sort((a, b) => a - b)
					.reduce((acc, curr, index) => acc + (index >= chartState.selectedYear.length - 2 ? index > chartState.selectedYear.length - 2 ? curr : curr + " and " : curr + ", "), "");
				return "in " + yearsList;
			});

		//end of drawCentralCircle
	};

	function drawSankeyContributions(dataContributions, flagsData) {

		let contributionsNoData = contributionsPanel.main.selectAll("." + classPrefix + "contributionsNoData")
			.data(dataContributions.nodes.length ? [] : [true]);

		const contributionsNoDataExit = contributionsNoData.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		contributionsNoData = contributionsNoData.enter()
			.append("text")
			.attr("class", classPrefix + "contributionsNoData")
			.attr("x", contributionsPanel.width / 2)
			.attr("y", contributionsPanel.height / 3)
			.style("opacity", 0)
			.text("No data for contributions")
			.merge(contributionsNoData)
			.transition()
			.duration(duration)
			.style("opacity", 1);

		dataContributions.nodes.reverse();

		const sankeyDataContributions = dataContributions.nodes.length ? sankeyGeneratorContributions(dataContributions) : dataContributions;

		const donorNodes = sankeyDataContributions.nodes.filter(e => e.level === 1);
		const fundNode = sankeyDataContributions.nodes.filter(e => e.level === 2);

		spreadNodes(donorNodes, false);
		spreadNodes(fundNode, false);

		sankeyGeneratorContributions.update(sankeyDataContributions);

		let sankeyNodesContributions = contributionsPanel.main.selectAll("." + classPrefix + "sankeyNodesContributions")
			.data(sankeyDataContributions.nodes, d => d.id);

		const sankeyNodesContributionsExit = sankeyNodesContributions.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyNodesContributionsEnter = sankeyNodesContributions.enter()
			.append("rect")
			.attr("class", classPrefix + "sankeyNodesContributions")
			.style("fill", contributionColor)
			.style("opacity", 0)
			.attr("y", d => d.x0)
			.attr("x", d => inverseContributionsScale(d.y1))
			.attr("width", d => Math.max(minNodeWidth, inverseContributionsScale(d.y0) - inverseContributionsScale(d.y1)))
			.attr("height", d => d.x1 - d.x0);

		sankeyNodesContributions = sankeyNodesContributionsEnter.merge(sankeyNodesContributions);

		sankeyNodesContributions.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("y", d => d.x0)
			.attr("x", d => inverseContributionsScale(d.y1))
			.attr("width", d => Math.max(minNodeWidth, inverseContributionsScale(d.y0) - inverseContributionsScale(d.y1)))
			.attr("height", d => d.x1 - d.x0);

		let sankeyLinksContributions = contributionsPanel.main.selectAll("." + classPrefix + "sankeyLinksContributions")
			.data(sankeyDataContributions.links, d => d.source.id);

		const sankeyLinksContributionsExit = sankeyLinksContributions.exit()
			.transition()
			.duration(duration)
			.style("stroke-opacity", 0)
			.remove();

		const sankeyLinksContributionsEnter = sankeyLinksContributions.enter()
			.append("path")
			.attr("class", classPrefix + "sankeyLinksContributions")
			.attr("stroke-width", d => Math.max(d.width, minStrokeWidth))
			.style("fill", "none")
			.style("stroke", contributionColor)
			.style("stroke-opacity", 0)
			.attr("d", drawLinks());

		sankeyLinksContributions = sankeyLinksContributionsEnter.merge(sankeyLinksContributions);

		sankeyLinksContributions.transition()
			.duration(duration)
			.style("stroke-opacity", linksOpacity)
			.attr("stroke-width", d => Math.max(d.width, minStrokeWidth))
			.attr("d", drawLinks());

		let sankeyDonorFlags = contributionsPanel.main.selectAll("." + classPrefix + "sankeyDonorFlags")
			.data(donorNodes, d => d.id);

		const sankeyDonorFlagsExit = sankeyDonorFlags.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyDonorFlagsEnter = sankeyDonorFlags.enter()
			.append("image")
			.attr("class", classPrefix + "sankeyDonorFlags")
			.style("opacity", 1)
			.attr("x", d => (inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2 - flagSize / 2)
			.attr("y", contributionsPanel.padding[0] - flagPadding - flagSize)
			.attr("width", flagSize)
			.attr("height", flagSize)
			.attr("href", d => {
				if (d.codeId === othersId) return blankFlag;
				//REMOVE, TEMPORARY ONLY
				if (d.id === "donor#211") return flagsData.qprv;
				if (lists.donorIsoCodes[d.codeId].toLowerCase() && !flagsData[lists.donorIsoCodes[d.codeId].toLowerCase()]) console.warn("Missing flag: " + d.name, d);
				return flagsData[lists.donorIsoCodes[d.codeId].toLowerCase()] || blankFlag;
			});

		sankeyDonorFlags = sankeyDonorFlagsEnter.merge(sankeyDonorFlags);

		sankeyDonorFlags.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => (inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2 - flagSize / 2);

		let otherFlags = contributionsPanel.main.selectAll("." + classPrefix + "otherFlags")
			.data(donorNodes[0].codeId === othersId ? donorNodes[0].othersData.slice(0, otherFlagsNumber).reverse() : [], d => d.id);

		const otherFlagsExit = otherFlags.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const otherFlagsEnter = otherFlags.enter()
			.append("image")
			.attr("class", classPrefix + "otherFlags")
			.style("opacity", 0)
			.attr("pointer-events", "none")
			.attr("x", (inverseContributionsScale(donorNodes[0].y1) + inverseContributionsScale(donorNodes[0].y0)) / 2 - flagSize / 2)
			.attr("y", contributionsPanel.padding[0] - flagPadding - flagSize)
			.attr("width", flagSize)
			.attr("height", flagSize)
			.attr("href", d => {
				if (lists.donorIsoCodes[d.codeId].toLowerCase() && !flagsData[lists.donorIsoCodes[d.codeId].toLowerCase()]) console.warn("Missing flag: " + d.name, d);
				return flagsData[lists.donorIsoCodes[d.codeId].toLowerCase()] || blankFlag;
			});

		otherFlags = otherFlagsEnter.merge(otherFlags);

		otherFlags.transition()
			.duration(duration)
			.style("opacity", (_, i) => (i + 1) / (Math.min(otherFlagsNumber, donorNodes[0].othersData.length)))
			.attr("x", (_, i) => (((Math.min(otherFlagsNumber, donorNodes[0].othersData.length)) - i - 1) * otherFlagsPadding) + (inverseContributionsScale(donorNodes[0].y1) + inverseContributionsScale(donorNodes[0].y0)) / 2 - flagSize / 2)
			.attr("y", (_, i) => contributionsPanel.padding[0] - flagPadding - flagSize + (((Math.min(otherFlagsNumber, donorNodes[0].othersData.length)) - i - 1) * otherFlagsPadding / 3));

		let sankeyDonorNames = contributionsPanel.main.selectAll("." + classPrefix + "sankeyDonorNames")
			.data(donorNodes, d => d.id);

		const sankeyDonorNamesExit = sankeyDonorNames.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyDonorNamesEnter = sankeyDonorNames.enter()
			.append("text")
			.attr("class", classPrefix + "sankeyDonorNames")
			.style("opacity", 0)
			.attr("x", d => (inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2)
			.attr("y", contributionsPanel.padding[0] - donorNamesPadding - flagSize - flagPadding)
			.attr("transform", d => `rotate(${angle}, ${(inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2}, ${contributionsPanel.padding[0] - donorNamesPadding - flagSize - flagPadding})`)
			.text(d => d.codeId === othersId ? "Others" : lists.donorNames[d.codeId])
			.call(createEllipsis, "donor");

		sankeyDonorNames = sankeyDonorNamesEnter.merge(sankeyDonorNames);

		sankeyDonorNames.text(d => d.codeId === othersId ? "Others" : lists.donorNames[d.codeId])
			.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("transform", d => `rotate(${angle}, ${(inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2}, ${contributionsPanel.padding[0] - donorNamesPadding - flagSize - flagPadding})`)
			.attr("x", d => (inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2)
			.call(createEllipsis, "donor");

		let sankeyDonorValues = contributionsPanel.main.selectAll("." + classPrefix + "sankeyDonorValues")
			.data(donorNodes, d => d.id);

		const sankeyDonorValuesExit = sankeyDonorValues.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyDonorValuesEnter = sankeyDonorValues.enter()
			.append("text")
			.attr("class", classPrefix + "sankeyDonorValues")
			.style("opacity", 0)
			.attr("x", d => (inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2)
			.attr("y", d => d.x1 + valuesPadding)
			.attr("dy", "0em")
			.text(d => "$0");

		sankeyDonorValues = sankeyDonorValuesEnter.merge(sankeyDonorValues);

		sankeyDonorValues.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => (inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2)
			.attr("dy", (d, i, n) => {
				if (!n[i + 1]) {
					return "0em";
				} else {
					const previousElement = d3.select(n[i + 1]);
					const previousElementDatum = previousElement.datum();
					const nextElement = d3.select(n[i - 1]);
					const nextDisplaced = n[i - 1] && nextElement.datum().displaced;
					if (!nextDisplaced && (inverseContributionsScale(previousElementDatum.y1) + inverseContributionsScale(previousElementDatum.y0)) / 2 + collisionPadding + donorValuesMeanLength > (inverseContributionsScale(d.y1) + inverseContributionsScale(d.y0)) / 2) {
						d.displaced = true;
						return "1.2em";
					} else {
						return "0em";
					};
				};
			})
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, d.value);
				return t => "$" + formatSIFloat(interpolator(t));
			});

		sankeyNodesContributions.on("mouseover", mouseOverNodesContributions)
			.on("mouseout", mouseOutContributions);

		sankeyDonorNames.on("mouseover", mouseOverNodesContributions)
			.on("mouseout", mouseOutContributions);

		sankeyDonorFlags.on("mouseover", mouseOverNodesContributions)
			.on("mouseout", mouseOutContributions);

		sankeyLinksContributions.on("mouseover", mouseOverLinksContributions)
			.on("mouseout", mouseOutContributions);

		function mouseOverNodesContributions(datum) {
			currentHoveredElement = this;
			sankeyNodesContributions.style("opacity", d => d.id === datum.id ? 1 : fadeOpacityNodes);
			sankeyLinksContributions.style("stroke-opacity", d => d.source.codeId === datum.codeId ? linksOpacity : fadeOpacityLinks);
			sankeyDonorNames.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			sankeyDonorFlags.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			sankeyDonorValues.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			otherFlags.style("opacity", (_, i) => (i + 1) / (Math.min(otherFlagsNumber, donorNodes[0].othersData.length)) * (datum.codeId === othersId ? 1 : fadeOpacityNodes));
			generateDonorTooltip(datum);
		};

		function mouseOverLinksContributions(datum) {
			currentHoveredElement = this;
			sankeyNodesContributions.style("opacity", d => datum.source.codeId === d.codeId ? 1 : fadeOpacityNodes);
			sankeyLinksContributions.style("stroke-opacity", (_, i, n) => n[i] === this ? linksOpacity : fadeOpacityLinks);
			sankeyDonorNames.style("opacity", d => d.codeId === datum.source.codeId ? 1 : fadeOpacityNodes);
			sankeyDonorFlags.style("opacity", d => d.codeId === datum.source.codeId ? 1 : fadeOpacityNodes);
			sankeyDonorValues.style("opacity", d => d.codeId === datum.source.codeId ? 1 : fadeOpacityNodes);
			generateDonorTooltip(datum.source);
		};

		function mouseOutContributions() {
			if (isSnapshotTooltipVisible) return;
			currentHoveredElement = null;
			sankeyNodesContributions.style("opacity", 1);
			sankeyLinksContributions.style("stroke-opacity", linksOpacity);
			sankeyDonorNames.style("opacity", 1);
			sankeyDonorFlags.style("opacity", 1);
			sankeyDonorValues.style("opacity", 1);
			otherFlags.style("opacity", (_, i) => (i + 1) / (Math.min(otherFlagsNumber, donorNodes[0].othersData.length)));
			tooltip.style("display", "none")
				.html(null);
		};

		function generateDonorTooltip(datum) {
			tooltip.style("display", "block")
				.html(null)

			const innerTooltipDiv = tooltip.append("div")
				.style("max-width", tooltipWidth + "px")
				.attr("id", classPrefix + "innerTooltipDiv");

			const titleDiv = innerTooltipDiv.append("div")
				.attr("class", classPrefix + "tooltipTitleDiv")
				.style("margin-bottom", "18px");

			if (datum.codeId !== othersId) {
				titleDiv.append("img")
					.attr("width", flagSize)
					.attr("height", flagSize)
					.style("margin-right", "8px")
					.attr("src", () => {
						//REMOVE, TEMPORARY ONLY
						if (datum.id === "donor#211") return flagsData.qprv;
						if (lists.donorIsoCodes[datum.codeId].toLowerCase() && !flagsData[lists.donorIsoCodes[datum.codeId].toLowerCase()]) console.warn("Missing flag: " + datum.name, d);
						return flagsData[lists.donorIsoCodes[datum.codeId].toLowerCase()] || blankFlag;
					});
			};

			const titleNameDiv = titleDiv.append("div")
				.attr("class", classPrefix + "titleNameDiv");

			titleNameDiv.append("strong")
				.style("font-size", "16px")
				.html(datum.codeId !== othersId ? datum.name : `Other donors (${datum.othersData.length} donors)`);

			if (lists.donorTypes[datum.codeId] && lists.donorTypes[datum.codeId] !== memberStateString) {
				titleNameDiv.append("div")
					.attr("class", classPrefix + "tooltipFooter")
					.html("(" + lists.donorTypes[datum.codeId] + ")");
			};

			const tooltipContainer = innerTooltipDiv.append("div")
				.style("margin", "0px")
				.style("display", "flex")
				.style("flex-wrap", "wrap")
				.style("white-space", "pre")
				.style("line-height", 1.4)
				.style("width", "100%");

			const rowDiv = tooltipContainer.append("div")
				.style("display", "flex")
				.style("align-items", "center")
				.style("margin-bottom", "4px")
				.style("width", "100%");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipKeys")
				.html("Total");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipLeader");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipValues")
				.html("$" + formatMoney0Decimals(datum.value));

			if (datum.codeId === othersId) {
				const headerDiv = tooltipContainer.append("div")
					.attr("class", classPrefix + "tooltipheaderDiv")
					.html("List of donors" + (datum.othersData.length > (maxOtherDonorsNumber + 1) ? ` (top ${maxOtherDonorsNumber} donors)` : ""));

				const tooltipOthersData = datum.othersData.length <= (maxOtherDonorsNumber + 1) ? datum.othersData :
					datum.othersData.reduce((acc, curr, index) => {
						if (curr.level === 1) {
							if (index < maxOtherDonorsNumber) {
								acc.push(curr)
							} else if (index === maxOtherDonorsNumber) {
								acc.push({
									codeId: tooltipOthersId,
									value: curr.value,
								});
							} else {
								acc[maxOtherDonorsNumber].value += curr.value;
							};
						};
						return acc;
					}, []);

				tooltipOthersData.forEach(row => {
					const rowDivOthers = tooltipContainer.append("div")
						.attr("class", classPrefix + "tooltipDivOthers")
						.style("display", "flex")
						.style("align-items", "center")
						.style("margin-bottom", "4px")
						.style("width", "100%");

					rowDivOthers.append("img")
						.attr("class", classPrefix + "tooltipKeys")
						.attr("width", flagSizeTooltip)
						.attr("height", flagSizeTooltip)
						.style("margin-right", "2px")
						.attr("src", () => {
							if (row.codeId === tooltipOthersId) return blankFlag;
							if (lists.donorIsoCodes[row.codeId].toLowerCase() && !flagsData[lists.donorIsoCodes[row.codeId].toLowerCase()]) console.warn("Missing flag: " + row.name, d);
							return flagsData[lists.donorIsoCodes[row.codeId].toLowerCase()] || blankFlag;
						});

					rowDivOthers.append("span")
						.attr("class", classPrefix + "tooltipKeys")
						.html(row.codeId !== tooltipOthersId ? row.name.slice(0, maxOthersNameLength) :
							`Remaining donors (${datum.othersData.length - maxOtherDonorsNumber} donors)`);

					rowDivOthers.append("span")
						.attr("class", classPrefix + "tooltipLeader");

					rowDivOthers.append("span")
						.attr("class", classPrefix + "tooltipValues")
						.html("$" + formatMoney0Decimals(row.value));
				});

			};

			const thisNodeBox = sankeyNodesContributions.filter(e => e.codeId === datum.codeId).node().getBoundingClientRect();

			const flagBox = sankeyDonorFlags.filter(e => e.codeId === datum.codeId).node().getBoundingClientRect();

			const containerBox = containerDiv.node().getBoundingClientRect();

			const tooltipBox = tooltip.node().getBoundingClientRect();

			const thisBoxLeft = Math.min(thisNodeBox.left, flagBox.left);

			const thisBoxRight = Math.max(thisNodeBox.right, flagBox.right);

			const thisBoxWidth = Math.max(thisNodeBox.width, flagBox.width);

			const thisOffsetTop = Math.max(padding[0], (flagBox.top + flagBox.height / 2 - tooltipBox.height / 2) - containerBox.top);

			const thisOffsetLeft = containerBox.right - thisBoxRight > tooltipBox.width + tooltipMargin ?
				thisBoxLeft - containerBox.left + thisBoxWidth + tooltipMargin :
				thisBoxLeft - containerBox.left - tooltipBox.width - tooltipMargin;

			tooltip.style("top", thisOffsetTop + "px")
				.style("left", thisOffsetLeft + "px");
		};

		//end of drawSankeyContributions
	};

	function drawSankeyAllocations(dataAllocations) {

		let allocationsNoData = allocationsPanel.main.selectAll("." + classPrefix + "allocationsNoData")
			.data(dataAllocations.nodes.length ? [] : [true]);

		const allocationsNoDataExit = allocationsNoData.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		allocationsNoData = allocationsNoData.enter()
			.append("text")
			.attr("class", classPrefix + "allocationsNoData")
			.attr("x", allocationsPanel.width / 2)
			.attr("y", allocationsPanel.height / 2)
			.style("opacity", 0)
			.text("No data for allocations")
			.merge(allocationsNoData)
			.transition()
			.duration(duration)
			.style("opacity", 1);

		dataAllocations.nodes.reverse();

		const sankeyDataAllocations = dataAllocations.nodes.length ? sankeyGeneratorAllocations(dataAllocations) : dataAllocations;

		const fundNode = sankeyDataAllocations.nodes.filter(e => e.level === 1);
		const partnerNodes = sankeyDataAllocations.nodes.filter(e => e.level === 2);
		const clusterNodes = sankeyDataAllocations.nodes.filter(e => e.level === 3);

		spreadNodes(fundNode, false);
		spreadNodes(partnerNodes, true);
		spreadNodes(clusterNodes, false);

		clusterColorsScale.domain(clusterNodes.map(d => d.id).reverse())
			.range(d3.range(clusterNodes.length).map(d => clusterColorsArray[~~((d / clusterNodes.length) * clusterColorsArray.length)]));

		sankeyGeneratorAllocations.update(sankeyDataAllocations);

		let sankeyNodesAllocations = allocationsPanel.main.selectAll("." + classPrefix + "sankeyNodesAllocations")
			.data(sankeyDataAllocations.nodes, d => d.id);

		const sankeyNodesAllocationsExit = sankeyNodesAllocations.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyNodesAllocationsEnter = sankeyNodesAllocations.enter()
			.append("rect")
			.attr("class", classPrefix + "sankeyNodesAllocations")
			.style("fill", d => d.level === 3 ? clusterColorsScale(d.id) : d3.color(allocationColor).darker(0.2))
			.style("opacity", 0)
			.attr("y", d => d.x0)
			.attr("x", d => inverseAllocationsScale(d.y1))
			.attr("width", d => Math.max(minNodeWidth, inverseAllocationsScale(d.y0) - inverseAllocationsScale(d.y1)))
			.attr("height", d => d.x1 - d.x0);

		sankeyNodesAllocations = sankeyNodesAllocationsEnter.merge(sankeyNodesAllocations);

		sankeyNodesAllocations.transition()
			.duration(duration)
			.style("opacity", 1)
			.style("fill", d => d.level === 3 ? clusterColorsScale(d.id) : d3.color(allocationColor).darker(0.2))
			.attr("y", d => d.x0)
			.attr("x", d => inverseAllocationsScale(d.y1))
			.attr("width", d => Math.max(minNodeWidth, inverseAllocationsScale(d.y0) - inverseAllocationsScale(d.y1)))
			.attr("height", d => d.x1 - d.x0);

		let sankeyLinksAllocations = allocationsPanel.main.selectAll("." + classPrefix + "sankeyLinksAllocations")
			.data(sankeyDataAllocations.links, d => d.source.id + d.target.id);

		const sankeyLinksAllocationsExit = sankeyLinksAllocations.exit()
			.transition()
			.duration(duration)
			.style("stroke-opacity", 0)
			.remove();

		const sankeyLinksAllocationsEnter = sankeyLinksAllocations.enter()
			.append("path")
			.attr("class", classPrefix + "sankeyLinksAllocations")
			.attr("stroke-width", d => Math.max(d.width, minStrokeWidth))
			.style("fill", "none")
			.style("stroke", d => d.source.level === 1 ? allocationColor : clusterColorsScale(d.target.id))
			.style("stroke-opacity", 0)
			.attr("d", drawLinks());

		sankeyLinksAllocations = sankeyLinksAllocationsEnter.merge(sankeyLinksAllocations);

		sankeyLinksAllocations.transition()
			.duration(duration)
			.style("stroke", d => d.source.level === 1 ? allocationColor : clusterColorsScale(d.target.id))
			.style("stroke-opacity", linksOpacity)
			.attr("stroke-width", d => Math.max(d.width, minStrokeWidth))
			.attr("d", drawLinks());

		let sankeyPartnerNames = allocationsPanel.main.selectAll("." + classPrefix + "sankeyPartnerNames")
			.data(partnerNodes, d => d.id);

		const sankeyPartnerNamesExit = sankeyPartnerNames.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyPartnerNamesEnter = sankeyPartnerNames.enter()
			.append("text")
			.attr("class", classPrefix + "sankeyPartnerNames")
			.style("opacity", 0)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.attr("y", d => d.x0 - namesPadding)
			.attr("transform", d => `rotate(${angle}, ${(inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2}, ${d.x0 - namesPadding})`)
			.text(d => lists.unAgencyShortNames[d.codeId])
			.call(createEllipsis, "partner");

		sankeyPartnerNames = sankeyPartnerNamesEnter.merge(sankeyPartnerNames);

		sankeyPartnerNames.text(d => lists.unAgencyShortNames[d.codeId])
			.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.attr("transform", d => `rotate(${angle}, ${(inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2}, ${d.x0 - namesPadding})`)
			.call(createEllipsis, "partner");

		let sankeyPartnerValues = allocationsPanel.main.selectAll("." + classPrefix + "sankeyPartnerValues")
			.data(partnerNodes, d => d.id);

		const sankeyPartnerValuesExit = sankeyPartnerValues.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyPartnerValuesEnter = sankeyPartnerValues.enter()
			.append("text")
			.attr("class", classPrefix + "sankeyPartnerValues")
			.style("opacity", 0)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.attr("y", d => d.x1 + valuesPadding)
			.text(d => "$0");

		sankeyPartnerValues = sankeyPartnerValuesEnter.merge(sankeyPartnerValues);

		sankeyPartnerValues.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, d.value);
				return t => "$" + formatSIFloat(interpolator(t));
			});

		let sankeyClusterNames = allocationsPanel.main.selectAll("." + classPrefix + "sankeyClusterNames")
			.data(clusterNodes, d => d.id);

		const sankeyClusterNamesExit = sankeyClusterNames.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyClusterNamesEnter = sankeyClusterNames.enter()
			.append("text")
			.attr("class", classPrefix + "sankeyClusterNames")
			.style("opacity", 0)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.attr("y", d => d.x0 - namesPadding)
			.attr("transform", d => `rotate(${angle}, ${(inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2}, ${d.x0 - namesPadding})`)
			.text(d => lists.clusterShortNames[d.codeId])
			.call(createEllipsis, "cluster");

		sankeyClusterNames = sankeyClusterNamesEnter.merge(sankeyClusterNames);

		sankeyClusterNames.text(d => lists.clusterShortNames[d.codeId])
			.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.attr("transform", d => `rotate(${angle}, ${(inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2}, ${d.x0 - namesPadding})`)
			.call(createEllipsis, "cluster");

		let sankeyClusterIcons = allocationsPanel.main.selectAll("." + classPrefix + "sankeyClusterIcons")
			.data(clusterNodes, d => d.id);

		const sankeyClusterIconsExit = sankeyClusterIcons.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyClusterIconsEnter = sankeyClusterIcons.enter()
			.append("image")
			.attr("class", classPrefix + "sankeyClusterIcons")
			.style("opacity", 0)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2 - clusterIconsSize / 2)
			.attr("y", d => d.x1 + clusterIconsPadding)
			.attr("width", clusterIconsSize)
			.attr("height", clusterIconsSize)
			.attr("href", d => clustersIconsData[d.codeId]);

		sankeyClusterIcons = sankeyClusterIconsEnter.merge(sankeyClusterIcons);

		sankeyClusterIcons.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2 - clusterIconsSize / 2);

		let sankeyClusterValues = allocationsPanel.main.selectAll("." + classPrefix + "sankeyClusterValues")
			.data(clusterNodes, d => d.id);

		const sankeyClusterValuesExit = sankeyClusterValues.exit()
			.transition()
			.duration(duration)
			.style("opacity", 0)
			.remove();

		const sankeyClusterValuesEnter = sankeyClusterValues.enter()
			.append("text")
			.attr("class", classPrefix + "sankeyClusterValues")
			.style("opacity", 0)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.attr("y", d => d.x1 + valuesPadding + clusterIconsSize)
			.text(d => "$0");

		sankeyClusterValues = sankeyClusterValuesEnter.merge(sankeyClusterValues);

		sankeyClusterValues.transition()
			.duration(duration)
			.style("opacity", 1)
			.attr("x", d => (inverseAllocationsScale(d.y1) + inverseAllocationsScale(d.y0)) / 2)
			.textTween((d, i, n) => {
				const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, d.value);
				return t => "$" + formatSIFloat(interpolator(t));
			});

		sankeyNodesAllocations.filter(d => d.level === 2)
			.on("mouseover", mouseOverPartnerNodes)
			.on("mouseout", mouseOutPartnerNodes);

		sankeyPartnerNames.on("mouseover", mouseOverPartnerNodes)
			.on("mouseout", mouseOutPartnerNodes);

		sankeyNodesAllocations.filter(d => d.level === 3)
			.on("mouseover", mouseOverClusterNodes)
			.on("mouseout", mouseOutClusterNodes);

		sankeyClusterNames.on("mouseover", mouseOverClusterNodes)
			.on("mouseout", mouseOutClusterNodes);

		sankeyClusterIcons.on("mouseover", mouseOverClusterNodes)
			.on("mouseout", mouseOutClusterNodes);

		sankeyLinksAllocations.filter(d => d.source.level === 1)
			.on("mouseover", mouseOverPartnerLinks)
			.on("mouseout", mouseOutPartnerLinks);

		sankeyLinksAllocations.filter(d => d.source.level === 2)
			.on("mouseover", mouseOverClusterLinks)
			.on("mouseout", mouseOutClusterLinks);

		function mouseOverPartnerNodes(datum) {
			currentHoveredElement = this;
			sankeyNodesAllocations.style("opacity", d => d.level === 2 && d.id === datum.id ? 1 :
				d.targetLinks.filter(e => e.source.id === datum.id).length ? 1 : fadeOpacityNodes);
			sankeyLinksAllocations.style("stroke-opacity", d => d.source.id === datum.id || d.target.id === datum.id ? linksOpacity : fadeOpacityLinks);
			sankeyPartnerNames.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			sankeyPartnerValues.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			sankeyClusterNames.style("opacity", d => d.targetLinks.filter(e => e.source.id === datum.id).length ? 1 : fadeOpacityNodes);
			sankeyClusterIcons.style("opacity", d => d.targetLinks.filter(e => e.source.id === datum.id).length ? 1 : fadeOpacityNodes);
			sankeyClusterValues.style("opacity", d => d.targetLinks.filter(e => e.source.id === datum.id).length ? 1 : fadeOpacityNodes);
			sankeyClusterValues.each((d, i, n) => {
				const amountFromPartner = d.targetLinks.reduce((acc, curr) => {
					if (curr.source.id === datum.id) acc += curr.value;
					return acc;
				}, 0);
				d3.select(n[i]).transition()
					.duration(duration)
					.textTween(() => {
						const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, amountFromPartner);
						return t => "$" + formatSIFloat(interpolator(t));
					});
			});
			generatePartnerTooltip(datum);
		};

		function mouseOutPartnerNodes() {
			if (isSnapshotTooltipVisible) return;
			currentHoveredElement = null;
			resetOpacity();
			tooltip.style("display", "none")
				.html(null);
		};

		function mouseOverClusterNodes(datum) {
			currentHoveredElement = this;
			sankeyNodesAllocations.style("opacity", d => d.level === 3 && d.id === datum.id ? 1 :
				d.sourceLinks.filter(e => e.target.id === datum.id).length ? 1 : fadeOpacityNodes);
			const linksToCluster = sankeyDataAllocations.nodes.reduce((acc, curr) => {
				const targets = curr.sourceLinks.map(e => e.target.id);
				if (curr.level === 2 && targets.includes(datum.id)) acc.push(curr.id);
				return acc;
			}, []);
			sankeyLinksAllocations.style("stroke-opacity", d => d.target.id === datum.id || linksToCluster.includes(d.target.id) ? linksOpacity : fadeOpacityLinks);
			sankeyPartnerNames.style("opacity", d => linksToCluster.includes(d.id) ? 1 : fadeOpacityNodes);
			sankeyPartnerValues.style("opacity", d => linksToCluster.includes(d.id) ? 1 : fadeOpacityNodes);
			sankeyClusterNames.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			sankeyClusterIcons.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			sankeyClusterValues.style("opacity", d => d.codeId === datum.codeId ? 1 : fadeOpacityNodes);
			sankeyPartnerValues.each((d, i, n) => {
				const amountFromCluster = d.sourceLinks.reduce((acc, curr) => {
					if (curr.target.id === datum.id) acc += curr.value;
					return acc;
				}, 0);
				d3.select(n[i]).transition()
					.duration(duration)
					.textTween(() => {
						const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, amountFromCluster);
						return t => "$" + formatSIFloat(interpolator(t));
					});
			});
			generateClusterTooltip(datum, "node");
		};

		function mouseOutClusterNodes() {
			if (isSnapshotTooltipVisible) return;
			currentHoveredElement = null;
			resetOpacity();
			tooltip.style("display", "none")
				.html(null);
		};

		function mouseOverPartnerLinks(datum) {
			currentHoveredElement = this;
			sankeyNodesAllocations.style("opacity", d => datum.target.id === d.id ||
				d.targetLinks.filter(e => e.source.id === datum.target.id).length ? 1 : fadeOpacityNodes);
			sankeyLinksAllocations.style("stroke-opacity", d => d.target.id === datum.target.id || d.source.id === datum.target.id ? linksOpacity : fadeOpacityLinks);
			sankeyPartnerNames.style("opacity", d => d.codeId === datum.target.codeId ? 1 : fadeOpacityNodes);
			sankeyPartnerValues.style("opacity", d => d.codeId === datum.target.codeId ? 1 : fadeOpacityNodes);
			sankeyClusterNames.style("opacity", d => d.targetLinks.filter(e => e.source.id === datum.target.id).length ? 1 : fadeOpacityNodes);
			sankeyClusterIcons.style("opacity", d => d.targetLinks.filter(e => e.source.id === datum.target.id).length ? 1 : fadeOpacityNodes);
			sankeyClusterValues.style("opacity", d => d.targetLinks.filter(e => e.source.id === datum.target.id).length ? 1 : fadeOpacityNodes);
			sankeyClusterValues.each((d, i, n) => {
				const amountFromPartner = d.targetLinks.reduce((acc, curr) => {
					if (curr.source.id === datum.target.id) acc += curr.value;
					return acc;
				}, 0);
				d3.select(n[i]).transition()
					.duration(duration)
					.textTween(() => {
						const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, amountFromPartner);
						return t => "$" + formatSIFloat(interpolator(t));
					});
			});
			generatePartnerTooltip(datum.target);
		};

		function mouseOutPartnerLinks() {
			if (isSnapshotTooltipVisible) return;
			currentHoveredElement = null;
			resetOpacity();
			tooltip.style("display", "none")
				.html(null);
		};

		function mouseOverClusterLinks(datum) {
			currentHoveredElement = this;
			sankeyNodesAllocations.style("opacity", d => datum.target.id === d.id || d.id === datum.source.id ? 1 : fadeOpacityNodes);
			sankeyLinksAllocations.style("stroke-opacity", (d, i, n) => d.target.id === datum.source.id || n[i] === this ? linksOpacity : fadeOpacityLinks);
			sankeyPartnerNames.style("opacity", d => d.id === datum.source.id ? 1 : fadeOpacityNodes);
			sankeyPartnerValues.style("opacity", d => d.id === datum.source.id ? 1 : fadeOpacityNodes);
			sankeyClusterNames.style("opacity", d => d.codeId === datum.target.codeId ? 1 : fadeOpacityNodes);
			sankeyClusterIcons.style("opacity", d => d.codeId === datum.target.codeId ? 1 : fadeOpacityNodes);
			sankeyClusterValues.style("opacity", d => d.codeId === datum.target.codeId ? 1 : fadeOpacityNodes);
			sankeyPartnerValues.each((d, i, n) => {
				const amountFromCluster = d.sourceLinks.reduce((acc, curr) => {
					if (curr.target.id === datum.target.id) acc += curr.value;
					return acc;
				}, 0);
				d3.select(n[i]).transition()
					.duration(duration)
					.textTween(() => {
						const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, amountFromCluster);
						return t => "$" + formatSIFloat(interpolator(t));
					});
			});
			sankeyClusterValues.each((d, i, n) => {
				const amountFromPartner = d.targetLinks.reduce((acc, curr) => {
					if (curr.source.id === datum.source.id) acc += curr.value;
					return acc;
				}, 0);
				d3.select(n[i]).transition()
					.duration(duration)
					.textTween(() => {
						const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, amountFromPartner);
						return t => "$" + formatSIFloat(interpolator(t));
					});
			});
			generateClusterTooltip(datum, "link");
		};

		function mouseOutClusterLinks() {
			if (isSnapshotTooltipVisible) return;
			currentHoveredElement = null;
			resetOpacity();
			tooltip.style("display", "none")
				.html(null);
		};

		function generatePartnerTooltip(datum) {
			tooltip.style("display", "block")
				.html(null)

			const innerTooltipDiv = tooltip.append("div")
				.style("max-width", tooltipWidthAllocations + "px")
				.attr("id", classPrefix + "innerTooltipDiv");

			const titleDiv = innerTooltipDiv.append("div")
				.attr("class", classPrefix + "tooltipTitleDiv")
				.style("margin-bottom", "18px");

			const titleNameDiv = titleDiv.append("div")
				.attr("class", classPrefix + "titleNameDiv");

			titleNameDiv.append("strong")
				.style("font-size", "16px")
				.html(lists.unAgencyNames[datum.codeId]);

			const tooltipContainer = innerTooltipDiv.append("div")
				.style("margin", "0px")
				.style("display", "flex")
				.style("flex-wrap", "wrap")
				.style("white-space", "pre")
				.style("line-height", 1.4)
				.style("width", "100%");

			const rowDiv = tooltipContainer.append("div")
				.style("display", "flex")
				.style("align-items", "center")
				.style("margin-bottom", "4px")
				.style("width", "100%");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipKeys")
				.html("Total");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipLeader");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipValues")
				.html("$" + formatMoney0Decimals(datum.value));

			const clustersData = clusterNodes.reduce((acc, curr) => {
				const foundPartner = curr.targetLinks.find(e => e.source.id === datum.id);
				if (foundPartner) {
					acc.push({
						codeId: foundPartner.target.codeId,
						value: foundPartner.value
					});
				};
				return acc;
			}, []).sort((a, b) => b.value - a.value);

			const headerDiv = tooltipContainer.append("div")
				.attr("class", classPrefix + "tooltipheaderDiv")
				.html("List of sectors");

			clustersData.forEach(row => {
				const rowDivOthers = tooltipContainer.append("div")
					.attr("class", classPrefix + "tooltipDivOthers")
					.style("display", "flex")
					.style("align-items", "center")
					.style("margin-bottom", "4px")
					.style("width", "100%");

				rowDivOthers.append("img")
					.attr("class", classPrefix + "tooltipKeys")
					.attr("width", clusterIconsSizeTooltip)
					.attr("height", clusterIconsSizeTooltip)
					.style("margin-right", "2px")
					.attr("src", clustersIconsData[row.codeId])

				rowDivOthers.append("span")
					.attr("class", classPrefix + "tooltipKeys")
					.html(lists.clusterNames[row.codeId]);

				rowDivOthers.append("span")
					.attr("class", classPrefix + "tooltipLeader");

				rowDivOthers.append("span")
					.attr("class", classPrefix + "tooltipValues")
					.html("$" + formatMoney0Decimals(row.value));
			});

			const thisNodeBox = sankeyNodesAllocations.filter(e => e.id === datum.id).node().getBoundingClientRect();

			const containerBox = containerDiv.node().getBoundingClientRect();

			const tooltipBox = tooltip.node().getBoundingClientRect();

			const thisOffsetTop = (thisNodeBox.top + thisNodeBox.height / 2 - tooltipBox.height / 2) - containerBox.top;

			const thisOffsetLeft = containerBox.right - thisNodeBox.right > tooltipBox.width + tooltipMargin ?
				thisNodeBox.left - containerBox.left + thisNodeBox.width + tooltipMargin :
				thisNodeBox.left - containerBox.left - tooltipBox.width - tooltipMargin;

			tooltip.style("top", thisOffsetTop + "px")
				.style("left", thisOffsetLeft + "px");
		};

		function generateClusterTooltip(datum, type) {
			tooltip.style("display", "block")
				.html(null)

			const innerTooltipDiv = tooltip.append("div")
				.style("max-width", tooltipWidthAllocations + "px")
				.attr("id", classPrefix + "innerTooltipDiv");

			const titleDiv = innerTooltipDiv.append("div")
				.attr("class", classPrefix + "tooltipTitleDiv")
				.style("margin-bottom", "18px");

			titleDiv.append("img")
				.attr("width", clusterIconsSize)
				.attr("height", clusterIconsSize)
				.style("margin-right", "8px")
				.style("filter", "grayscale(100%) brightness(10)")
				.attr("src", type === "node" ? clustersIconsData[datum.codeId] : clustersIconsData[datum.target.codeId]);

			const titleNameDiv = titleDiv.append("div")
				.attr("class", classPrefix + "titleNameDiv");

			titleNameDiv.append("strong")
				.style("font-size", "16px")
				.html(type === "node" ? lists.clusterNames[datum.codeId] : lists.clusterNames[datum.target.codeId]);

			if (type === "link") {
				titleNameDiv.append("div")
					.attr("class", classPrefix + "tooltipFooter")
					.html("(from: " + lists.unAgencyNames[datum.source.codeId] + ")");
			};

			const tooltipContainer = innerTooltipDiv.append("div")
				.style("margin", "0px")
				.style("display", "flex")
				.style("flex-wrap", "wrap")
				.style("white-space", "pre")
				.style("line-height", 1.4)
				.style("width", "100%");

			const rowDiv = tooltipContainer.append("div")
				.style("display", "flex")
				.style("align-items", "center")
				.style("margin-bottom", "4px")
				.style("width", "100%");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipKeys")
				.html("Total");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipLeader");

			rowDiv.append("span")
				.attr("class", classPrefix + "tooltipValues")
				.html("$" + formatMoney0Decimals(datum.value));

			if (type === "node") {

				const partnersData = partnerNodes.reduce((acc, curr) => {
					const foundCluster = curr.sourceLinks.find(e => e.target.id === datum.id);
					if (foundCluster) {
						acc.push({
							codeId: foundCluster.source.codeId,
							value: foundCluster.value
						});
					};
					return acc;
				}, []).sort((a, b) => b.value - a.value);

				const headerDiv = tooltipContainer.append("div")
					.attr("class", classPrefix + "tooltipheaderDiv")
					.html("List of Agencies");

				partnersData.forEach(row => {
					const rowDivOthers = tooltipContainer.append("div")
						.attr("class", classPrefix + "tooltipDivOthers")
						.style("display", "flex")
						.style("align-items", "center")
						.style("margin-bottom", "4px")
						.style("width", "100%");

					rowDivOthers.append("span")
						.attr("class", classPrefix + "tooltipKeys")
						.html(lists.unAgencyShortNames[row.codeId]);

					rowDivOthers.append("span")
						.attr("class", classPrefix + "tooltipLeader");

					rowDivOthers.append("span")
						.attr("class", classPrefix + "tooltipValues")
						.html("$" + formatMoney0Decimals(row.value));
				});

			};

			const thisNodeBox = type === "node" ?
				sankeyNodesAllocations.filter(e => e.id === datum.id).node().getBoundingClientRect() :
				sankeyLinksAllocations.filter(e => e.source.id === datum.source.id && e.target.id === datum.target.id).node().getBoundingClientRect();

			const containerBox = containerDiv.node().getBoundingClientRect();

			const tooltipBox = tooltip.node().getBoundingClientRect();

			const thisOffsetTop = Math.min(containerBox.height - tooltipBox.height - padding[2], (thisNodeBox.top + thisNodeBox.height / 2 - tooltipBox.height / 2) - containerBox.top);

			const thisOffsetLeft = containerBox.right - thisNodeBox.right > tooltipBox.width + tooltipMargin ?
				thisNodeBox.left - containerBox.left + thisNodeBox.width + tooltipMargin :
				Math.max(0, thisNodeBox.left - containerBox.left - tooltipBox.width - tooltipMargin);

			tooltip.style("top", thisOffsetTop + "px")
				.style("left", thisOffsetLeft + "px");
		};

		function resetOpacity() {
			sankeyNodesAllocations.style("opacity", 1);
			sankeyLinksAllocations.style("stroke-opacity", linksOpacity);
			sankeyPartnerNames.style("opacity", 1);
			sankeyPartnerValues.style("opacity", 1);
			sankeyClusterNames.style("opacity", 1);
			sankeyClusterIcons.style("opacity", 1);
			sankeyClusterValues.style("opacity", 1);
			sankeyClusterValues.transition()
				.duration(duration)
				.textTween((d, i, n) => {
					const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, d.value);
					return t => "$" + formatSIFloat(interpolator(t));
				});
			sankeyPartnerValues.transition()
				.duration(duration)
				.textTween((d, i, n) => {
					const interpolator = d3.interpolate(reverseFormat(n[i].textContent.split("$")[1]) || 0, d.value);
					return t => "$" + formatSIFloat(interpolator(t));
				});
		};

		//end of drawSankeyAllocations
	};

	function preProcessData(rawDataAllocations, rawDataContributions) {
		yearsArrayAllocations.push(...new Set(rawDataAllocations.map(e => e.allocationYear)));
		yearsArrayContributions.push(...new Set(rawDataContributions.map(e => e.contributionYear)));
		yearsArrayAllocations.sort((a, b) => a - b);
		yearsArrayContributions.sort((a, b) => a - b);
		yearsArrayAllocations.forEach(e => {
			if (!yearsArray.includes(e)) yearsArray.push(e);
		});
		yearsArrayContributions.forEach(e => {
			if (!yearsArray.includes(e)) yearsArray.push(e);
		});
	};

	function processDataAllocations(rawDataAllocations) {

		const data = {
			nodes: [],
			links: []
		};

		const fundNode = {
			codeId: null,
			level: 1,
			name: null,
			value: 0,
			id: fundId
		};

		rawDataAllocations.forEach(row => {
			if (chartState.selectedYear.includes(row.allocationYear) && chartState.selectedFund.includes(row.fundId) && row.budget) {

				const foundPartner = data.nodes.find(d => d.level === 2 && d.codeId === row.partnerCode);

				const foundCluster = data.nodes.find(d => d.level === 3 && d.codeId === row.ClusterCBPFCERFId);

				if (foundPartner) {
					foundPartner.value += row.budget;
				} else {
					data.nodes.push({
						codeId: row.partnerCode,
						level: 2,
						name: lists.unAgencyNames[row.partnerCode],
						value: row.budget,
						id: "partner#" + row.partnerCode
					});
				};

				if (foundCluster) {
					foundCluster.value += row.budget;
				} else {
					data.nodes.push({
						codeId: row.ClusterCBPFCERFId,
						level: 3,
						name: lists.clusterNames[row.ClusterCBPFCERFId],
						value: row.budget,
						id: "cluster#" + row.ClusterCBPFCERFId
					});
				};

				const foundLinkToPartner = data.links.find(d => d.target === "partner#" + row.partnerCode);

				const foundLinkToCluster = data.links.find(d => d.source === "partner#" + row.partnerCode && d.target === "cluster#" + row.ClusterCBPFCERFId);

				if (foundLinkToPartner) {
					foundLinkToPartner.value += row.budget;
				} else {
					data.links.push({
						source: fundId,
						target: "partner#" + row.partnerCode,
						value: row.budget
					});
				};

				if (foundLinkToCluster) {
					foundLinkToCluster.value += row.budget;
				} else {
					data.links.push({
						source: "partner#" + row.partnerCode,
						target: "cluster#" + row.ClusterCBPFCERFId,
						value: row.budget
					});
				};

				fundNode.value += row.budget;

			};
		});

		data.nodes.sort((a, b) => b.value - a.value);

		if (data.nodes.length) data.nodes.push(fundNode);

		return data;

		//end of processDataAllocations;
	};

	function processDataContributions(rawDataContributions) {

		const data = {
			nodes: [],
			links: []
		};

		const fundNode = {
			codeId: null,
			level: 2,
			name: null,
			value: 0,
			id: fundId
		};

		rawDataContributions.forEach(row => {
			if (chartState.selectedYear.includes(row.contributionYear) && chartState.selectedFund.includes(row.fundId) && (row.paidAmount + row.pledgedAmount) && +row.donorId === +row.donorId) {

				const foundSource = data.nodes.find(d => d.level === 1 && d.codeId === row.donorId);

				if (foundSource) {
					foundSource.value += row.paidAmount + row.pledgedAmount;
				} else {
					data.nodes.push({
						codeId: row.donorId,
						level: 1,
						name: lists.donorNames[row.donorId],
						value: row.paidAmount + row.pledgedAmount,
						id: "donor#" + row.donorId
					});
				};

				const foundLink = data.links.find(d => d.source === "donor#" + row.donorId);

				if (foundLink) {
					foundLink.value += row.paidAmount + row.pledgedAmount;
				} else {
					data.links.push({
						source: "donor#" + row.donorId,
						target: fundId,
						value: row.paidAmount + row.pledgedAmount
					});
				};

				fundNode.value += row.paidAmount + row.pledgedAmount;

			};
		});

		data.nodes.sort((a, b) => b.value - a.value);

		data.nodes = data.nodes.length <= maxOtherDonorsNumber + 1 ? data.nodes :
			data.nodes.reduce((acc, curr, index) => {
				if (index < maxDonorsNumber) {
					acc.push(curr)
				} else if (index === maxDonorsNumber) {
					acc.push({
						codeId: othersId,
						level: 1,
						name: othersName,
						value: curr.value,
						id: "donor#" + othersId,
						othersData: [curr]
					});
				} else {
					acc[maxDonorsNumber].value += curr.value;
					acc[maxDonorsNumber].othersData.push(curr);
				};
				return acc;
			}, []);

		if (data.nodes.length) data.nodes.push(fundNode);

		const donorsInData = data.nodes.map(d => d.id);

		data.links = data.links.reduce((acc, curr) => {
			if (donorsInData.includes(curr.source)) {
				acc.push(curr);
			} else {
				const foundOthers = acc.find(e => e.source === "donor#" + othersId);
				if (foundOthers) {
					foundOthers.value += curr.value;
				} else {
					acc.push({
						source: "donor#" + othersId,
						target: fundId,
						value: curr.value
					});
				};
			};
			return acc;
		}, []);

		return data;

		//end of processDataContributions;
	};

	function createCsvAllocations(rawDataAllocations) {

		const csvData = [];

		rawDataAllocations.forEach(function(row) {
			if (chartState.selectedYear.includes(row.allocationYear) && chartState.selectedFund.includes(row.fundId)) {
				csvData.push({
					Year: row.allocationYear,
					Cluster: lists.clusterNames[row.ClusterCBPFCERFId],
					Agency: lists.unAgencyShortNames[row.partnerCode],
					Budget: row.budget
				});
			};
		});

		const csv = d3.csvFormat(csvData);

		return csv;
	};

	function createCsvContributions(rawDataContributions) {

		const csvData = [];

		rawDataContributions.forEach(function(row) {
			if (chartState.selectedYear.includes(row.contributionYear) && chartState.selectedFund.includes(row.fundId)) {
				csvData.push({
					Year: row.contributionYear,
					Donor: lists.donorNames[row.donorId],
					"Donor type": lists.donorTypes[row.donorId],
					Paid: row.paidAmount,
					Pledged: row.pledgedAmount,
					Total: row.paidAmount + row.pledgedAmount
				});
			};
		});

		const csv = d3.csvFormat(csvData);

		return csv;
	};

	function createSnapshot(type, fromContextMenu) {

		const downloadingDiv = d3.select("body").append("div")
			.style("position", "fixed")
			.attr("id", classPrefix + "DownloadingDiv")
			.style("left", window.innerWidth / 2 - 100 + "px")
			.style("top", window.innerHeight / 2 - 100 + "px");

		const downloadingDivSvg = downloadingDiv.append("svg")
			.attr("class", classPrefix + "DownloadingDivSvg")
			.attr("width", 200)
			.attr("height", 100);

		const downloadingDivText = "Downloading " + type.toUpperCase();

		createProgressWheel(downloadingDivSvg, 200, 175, downloadingDivText);

		const svgRealSize = svg.node().getBoundingClientRect();

		svg.attr("width", svgRealSize.width)
			.attr("height", svgRealSize.height);

		const listOfStyles = [
			"font-size",
			"font-family",
			"font-weight",
			"fill",
			"stroke",
			"stroke-dasharray",
			"stroke-width",
			"opacity",
			"text-anchor",
			"text-transform",
			"shape-rendering",
			"letter-spacing",
			"white-space",
			"dominant-baseline",
			"letter-spacing",
			"paint-order"
		];

		const imageDiv = containerDiv.node();

		setSvgStyles(svg.node());

		if (type === "png") {
			iconsDiv.style("opacity", 0);
		} else {
			topDiv.style("opacity", 0)
		};

		snapshotTooltip.style("display", "none");

		html2canvas(imageDiv).then(function(canvas) {

			svg.attr("width", null)
				.attr("height", null);

			if (type === "png") {
				iconsDiv.style("opacity", 1);
			} else {
				topDiv.style("opacity", 1)
			};

			if (type === "png") {
				downloadSnapshotPng(canvas);
			} else {
				downloadSnapshotPdf(canvas);
			};

			if (fromContextMenu && currentHoveredElement) d3.select(currentHoveredElement).dispatch("mouseout");

		});

		function setSvgStyles(node) {

			if (!node.style) return;

			let styles = getComputedStyle(node);

			for (let i = 0; i < listOfStyles.length; i++) {
				node.style[listOfStyles[i]] = styles[listOfStyles[i]];
			};

			for (let i = 0; i < node.childNodes.length; i++) {
				setSvgStyles(node.childNodes[i]);
			};
		};

		//end of createSnapshot
	};

	function downloadSnapshotPng(source) {

		const currentDate = new Date();

		const fileName = vizNameQueryString + "_" + csvDateFormat(currentDate) + ".png";

		source.toBlob(function(blob) {
			const url = URL.createObjectURL(blob);
			const link = document.createElement("a");
			if (link.download !== undefined) {
				link.setAttribute("href", url);
				link.setAttribute("download", fileName);
				link.style = "visibility:hidden";
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			} else {
				window.location.href = url;
			};
		});

		removeProgressWheel();

		d3.select("#" + classPrefix + "DownloadingDiv").remove();

	};

	function downloadSnapshotPdf(source) {

		const pdfMargins = {
			top: 10,
			bottom: 30,
			left: 20,
			right: 30
		};

		d3.image("./assets/img/UNOCHA_logo_vertical_blue_RGB.png")
			.then(function(logo) {

				let pdf;

				const point = 2.834646;

				const sourceDimentions = containerDiv.node().getBoundingClientRect();
				const widthInMilimeters = 210 - pdfMargins.left * 2;
				const heightInMilimeters = widthInMilimeters * (sourceDimentions.height / sourceDimentions.width);
				const maxHeightInMilimeters = 180;
				let pdfHeight;

				if (heightInMilimeters > maxHeightInMilimeters) {
					pdfHeight = 297 + heightInMilimeters - maxHeightInMilimeters;
					pdf = new jsPDF({
						format: [210 * point, (pdfHeight) * point],
						unit: "mm"
					})
				} else {
					pdfHeight = 297;
					pdf = new jsPDF();
				}

				let pdfTextPosition;

				createLetterhead();

				pdf.setTextColor(80, 80, 90);
				pdf.setFont('helvetica');
				pdf.setFontType("bold");
				pdf.setFontSize(14);
				pdf.text("CERF by year", pdfMargins.left, 44);

				pdf.addImage(source, "PNG", pdfMargins.left, 48, widthInMilimeters, heightInMilimeters);

				const currentDate = new Date();

				//pdf.output("dataurlnewwindow");
				pdf.save(vizNameQueryString + "_" + csvDateFormat(currentDate) + ".pdf");

				removeProgressWheel();

				d3.select("#" + classPrefix + "DownloadingDiv").remove();

				function createLetterhead() {

					const footer = pdf.splitTextToSize("The mission of the United Nations Office for the Coordination of Humanitarian Affairs (OCHA) is to Coordinate the global emergency response to save lives and protect people in humanitarian crises. We advocate for effective and principled humanitarian action by all, for all.", (210 - pdfMargins.left - pdfMargins.right), {
						fontSize: 8
					});

					pdf.setFillColor(65, 143, 222);
					pdf.rect(pdfMargins.left, pdfMargins.top + 20, 210 - pdfMargins.right, 0.75, "F");
					pdf.rect(pdfMargins.left, pdfHeight - pdfMargins.bottom, 210 - pdfMargins.right, 0.75, "F");
					pdf.rect(pdfMargins.left + 22, pdfMargins.top + 2, 0.25, 15, "F");

					const fullDate = d3.timeFormat("%A, %d %B %Y")(new Date());

					pdf.setTextColor(35, 143, 222);
					pdf.setFontType("normal");
					pdf.setFontSize(14);
					pdf.text("CERF DATA HUB", pdfMargins.left + 26, 20);

					pdf.setTextColor(35, 143, 222);
					pdf.setFontType("normal");
					pdf.setFontSize(10);
					pdf.text(fullDate, pdfMargins.left + 26, 26.1);


					// pdf.setFillColor(236, 161, 84);
					// pdf.rect(0, pdfMargins.top + 15, 210, 2, "F");

					// pdf.setFillColor(255, 255, 255);
					// pdf.rect(pdfMargins.left, pdfMargins.top - 1, 94, 20, "F");

					// pdf.ellipse(pdfMargins.left, pdfMargins.top + 9, 5, 9, "F");
					// pdf.ellipse(pdfMargins.left + 94, pdfMargins.top + 9, 5, 9, "F");

					pdf.addImage(logo, "PNG", pdfMargins.left + 2, pdfMargins.top, 14, 18);

					// pdf.setFillColor(236, 161, 84);
					// pdf.rect(0, pdfHeight - pdfMargins.bottom, 210, 2, "F");

					pdf.setTextColor(35, 143, 222);
					pdf.setFont("helvetica");
					pdf.setFontType("normal");
					pdf.setFontSize(8);
					pdf.text(footer, 105, pdfHeight - pdfMargins.bottom + 6, {
						align: "center"
					});

					pdf.setTextColor(35, 143, 222);
					pdf.setFont("helvetica");
					pdf.setFontType("bold");
					pdf.setFontSize(8);
					pdf.text("www.unocha.org", 105, pdfHeight - pdfMargins.bottom + 16, {
						align: "center"
					});

				};

			});

		//end of downloadSnapshotPdf
	};

	function spreadNodes(nodes, padding) {
		const spacer = freeNodeSpace / (nodes.length + 1);
		nodes.forEach((node, index) => {
			if (padding) {
				node.x0 += partnersPadding;
				node.x1 += partnersPadding;
			};
			node.y0 += spacer * (index + 1);
			node.y1 += spacer * (index + 1);
		});
	};

	function horizontalSource(d) {
		return [inverseContributionsScale(d.y0), d.source.x1];
	};

	function horizontalTarget(d) {
		return [inverseContributionsScale(d.y1), d.target.x0];
	};

	function drawLinks() {
		return d3.linkVertical()
			.source(horizontalSource)
			.target(horizontalTarget);
	};

	function createEllipsis(selection, type) {
		selection.each((d, i, n) => {
			if (type !== "donor" && i) return;
			let thisText = n[i].textContent;
			while (n[i].getComputedTextLength() > maxDonorTextLength / (i < 2 ? 1.6 : 1)) {
				d3.select(n[i]).text((thisText = thisText.slice(0, -1)) + "...");
			};
		});
	};

	function createDonorNamesList(donorsData) {
		donorsData.forEach(row => {
			lists.donorNames[row.id + ""] = row.donorName;
			lists.donorTypes[row.id + ""] = row.donorType;
			lists.donorIsoCodes[row.id + ""] = row.donorISO2Code;
		});
	};

	function createFundNamesList(fundsData) {
		fundsData.forEach(row => {
			lists.fundNames[row.id + ""] = row.PooledFundName;
			lists.fundAbbreviatedNames[row.id + ""] = row.PooledFundNameAbbrv;
			lists.fundRegions[row.id + ""] = row.RegionName;
			lists.fundIsoCodes[row.id + ""] = row.ISO2Code;
			lists.fundIsoCodes3[row.id + ""] = row.CountryCode;
			if (row.PooledFundName === "CERF") cerfPooledFundId = row.id;
		});
	};

	function createAllocationTypesList(allocationTypesData) {
		allocationTypesData.forEach(row => {
			lists.allocationTypes[row.id + ""] = row.AllocationName;
		});
	};

	function createPartnerTypesList(partnersData) {
		partnersData.forEach(row => {
			lists.partnerTypes[row.id + ""] = row.OrganizationTypeName;
		});
	};

	function createUnAgenciesNamesList(unAgenciesData) {
		unAgenciesData.forEach(row => {
			lists.unAgencyNames[row.agencyID + ""] = row.agencyName;
			lists.unAgencyShortNames[row.agencyID + ""] = row.agencyCode;
		});
	};

	function createClustersList(clustersData) {
		clustersData.forEach(row => {
			lists.clusterNames[row.id + ""] = row.ClustNm;
			lists.clusterShortNames[row.id + ""] = clusterNamesScale(row.ClustNm);
		});
	};

	function fetchFile(fileName, url, warningString, method) {
		if (localStorage.getItem(fileName) &&
			JSON.parse(localStorage.getItem(fileName)).timestamp > (currentDate.getTime() - localStorageTime)) {
			const fetchedData = method === "csv" ? d3.csvParse(JSON.parse(localStorage.getItem(fileName)).data, d3.autoType) :
				JSON.parse(localStorage.getItem(fileName)).data;
			console.info("CERF BI chart info: " + warningString + " from local storage");
			return Promise.resolve(fetchedData);
		} else {
			const fetchMethod = method === "csv" ? d3.csv : d3.json;
			const rowFunction = method === "csv" ? d3.autoType : null;
			return fetchMethod(url, rowFunction).then(fetchedData => {
				try {
					localStorage.setItem(fileName, JSON.stringify({
						data: method === "csv" ? d3.csvFormat(fetchedData) : fetchedData,
						timestamp: currentDate.getTime()
					}));
				} catch (error) {
					console.info("CERF BI chart, " + error);
				};
				console.info("CERF BI chart info: " + warningString + " from API");
				return fetchedData;
			});
		};
	};

	function validateYear(yearString) {
		if (yearString.toLowerCase() === allYearsOption) {
			chartState.selectedYear.push(allYearsOption);
			return;
		};
		const allYears = yearString.split(",").map(d => +(d.trim())).sort((a, b) => a - b);
		allYears.forEach(d => {
			if (d && yearsArray.includes(d)) chartState.selectedYear.push(d);
		});
		if (!chartState.selectedYear.length) chartState.selectedYear.push(new Date().getFullYear());
	};

	function validateCustomEventYear(yearNumber) {
		if (yearsArray.includes(yearNumber)) {
			return yearNumber;
		};
		while (!yearsArray.includes(yearNumber)) {
			yearNumber = yearNumber >= currentYear ? yearNumber - 1 : yearNumber + 1;
		};
		return yearNumber;
	};

	function setYearsDescriptionDiv() {
		yearsDescriptionDiv.html(function() {
			if (chartState.selectedYear.length <= maxYearsListNumber) return null;
			const yearsList = chartState.selectedYear.sort(function(a, b) {
				return a - b;
			}).reduce(function(acc, curr, index) {
				return acc + (index >= chartState.selectedYear.length - 2 ? index > chartState.selectedYear.length - 2 ? curr : curr + " and " : curr + ", ");
			}, "");
			return "\u002ASelected years: " + yearsList;
		});
	};

	function parseTransform(translate) {
		const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
		group.setAttributeNS(null, "transform", translate);
		const matrix = group.transform.baseVal.consolidate().matrix;
		return [matrix.e, matrix.f];
	};

	function formatSIFloat(value) {
		const length = (~~Math.log10(value) + 1) % 3;
		const digits = length === 1 ? 2 : length === 2 ? 1 : 0;
		return d3.formatPrefix("." + digits, value)(value).replace("G", "B");
	};

	function reverseFormat(s) {
		if (+s === 0) return 0;
		let returnValue;
		const transformation = {
			Y: Math.pow(10, 24),
			Z: Math.pow(10, 21),
			E: Math.pow(10, 18),
			P: Math.pow(10, 15),
			T: Math.pow(10, 12),
			G: Math.pow(10, 9),
			B: Math.pow(10, 9),
			M: Math.pow(10, 6),
			k: Math.pow(10, 3),
			h: Math.pow(10, 2),
			da: Math.pow(10, 1),
			d: Math.pow(10, -1),
			c: Math.pow(10, -2),
			m: Math.pow(10, -3),
			: Math.pow(10, -6),
			n: Math.pow(10, -9),
			p: Math.pow(10, -12),
			f: Math.pow(10, -15),
			a: Math.pow(10, -18),
			z: Math.pow(10, -21),
			y: Math.pow(10, -24)
		};
		Object.keys(transformation).some(function(k) {
			if (s.indexOf(k) > 0) {
				returnValue = parseFloat(s.split(k)[0]) * transformation[k];
				return true;
			}
		});
		return returnValue;
	};

	function createProgressWheel(thissvg, thiswidth, thisheight, thistext) {
		const wheelGroup = thissvg.append("g")
			.attr("class", classPrefix + "d3chartwheelGroup")
			.attr("transform", "translate(" + thiswidth / 2 + "," + thisheight / 4 + ")");

		const loadingText = wheelGroup.append("text")
			.attr("text-anchor", "middle")
			.style("font-family", "Roboto")
			.style("font-weight", "bold")
			.style("font-size", "11px")
			.attr("y", 50)
			.attr("class", "contributionColorFill")
			.text(thistext);

		const arc = d3.arc()
			.outerRadius(25)
			.innerRadius(20);

		const wheel = wheelGroup.append("path")
			.datum({
				startAngle: 0,
				endAngle: 0
			})
			.classed("contributionColorFill", true)
			.attr("d", arc);

		transitionIn();

		function transitionIn() {
			wheel.transition()
				.duration(1000)
				.attrTween("d", function(d) {
					const interpolate = d3.interpolate(0, Math.PI * 2);
					return function(t) {
						d.endAngle = interpolate(t);
						return arc(d)
					}
				})
				.on("end", transitionOut)
		};

		function transitionOut() {
			wheel.transition()
				.duration(1000)
				.attrTween("d", function(d) {
					const interpolate = d3.interpolate(0, Math.PI * 2);
					return function(t) {
						d.startAngle = interpolate(t);
						return arc(d)
					}
				})
				.on("end", function(d) {
					d.startAngle = 0;
					transitionIn()
				})
		};

		//end of createProgressWheel
	};

	function removeProgressWheel() {
		const wheelGroup = d3.select("." + classPrefix + "d3chartwheelGroup");
		wheelGroup.select("path").interrupt();
		wheelGroup.remove();
	};

	//end of d3ChartIIFE
}());